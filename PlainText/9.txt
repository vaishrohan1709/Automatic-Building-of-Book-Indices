  makeatletter ef  list I margin margini  setlength  sep  0pt plus 1pt minus 1pt   setlengt h opsep  2pt plus 1pt minus 1pt   setlengt h emsep  0pt    t  listi  listI   listi ef  listii   margin marginii width marginii  advance width- sep  setlength  opsep  0pt plus 1pt minus 1pt    ef  listii i margin marginiii width marginiii  advance width- sep  setlength  opsep  0pt plus 1pt minus 1pt   setlengt h sep  0pt   setlengt h topsep  1pt plus 0pt minus 1pt     makeatother We prove new results concerning the relation between bifix codes  episturmian words and subgroups of free groups  We study bifix codes in factorial sets of words  We generalize most properties of ordinary maximal bifix codes to bifix codes maximal in a recurrent set of words  -maximal bifix codes   In the case of bifix codes contained in Sturmian sets of words  we obtain several new results  Let be a Sturmian set of words  defined as the set of factors of a strict episturmian word  Our results express the fact that an -maximal bifix code of degree behaves just as the set of words of of length  An -maximal bifix code of degree in a Sturmian set of words on an alphabet with letters has elements  This generalizes the fact that a Sturmian set contains words of length  Moreover  given an infinite word if there is a finite maximal bifix code of degree such that has at most factors of length in then is ultimately periodic  Our main result states that any -maximal bifix code of degree on the alphabet is the basis of a subgroup of index of the free group on
Introduction
 This paper studies a new relation between three objects previously unrelated altogether  bifix codes  epiturmian words and subgroups of free groups  We first give some elements on the background of the first two  The study of bifix codes goes back to founding papers by Sch  utzenberger Schutzenberger1956 and by Gilbert and Moore GilbertMoore1959  These papers already contain significant results  The first systematic study is in the papers of Sch  utzenberger Schutzenberger1961c Schutzenberger1961b  The general idea is that the submonoids generated by bifix codes are an adequate generalization of the subgroups of a group  This is illustrated by the striking fact that  under a mild restriction  the average length of a maximal bifix code with respect to a Bernoulli distribution on the alphabet is an integer  Thus  in some sense a maximal bifix code behaves as the uniform code formed of all the words of a given length  The theory of bifix codes was developed in a considerable way by C  esari  He proved that all the finite maximal bifix codes may be obtained by internal transformations from uniform codes Cesari1972  He also defined the notion of derived code which allows to build maximal bifix codes by increasing degrees Cesari1979  Sturmian words are infinite words over a binary alphabet that have exactly factors of length for each  Their origin can be traced back to the astronomer J  Bernoulli III  Their first in-depth study is by Morse and Hedlund MorseHedlund1940  Many combinatorial properties were described in the paper by Coven and Hedlund CovenHedlund1973  Note that  although Sturmian words appear first in the work of Morse and Hedlund  their finitary version  Christoffel and standard words  appear much before in the work of Christoffel Christoffel1875 and  apparently independently  in the work of Markoff Markoff1879 Markoff1880   the latter constructed the famous Markoff numbers by using them  The Markoff theory  which was designed to study minima s of quadratic forms  was revisited often by mathematicians  notably by Frobenius Frobenius1913 Dickson Dickson1930 H  Cohn Cohn1972 Cusick and Flahive CusickFlahive1989 and Bombieri Bombieri2007  There  the connection with the free group on two generators was established  Other connection of Christoffel words with the free group may be found in Osborne and Zieschang OsborneZieschang1981 and Kassel and Reutenauer KasselReutenauer2007  Moreover  the Sturmian morphisms  substitutions that preserve Sturmian words  are the positive endomorphisms of the free group on two generators  see Wen and Wen WenWen1994 Mignosi and S  e  ebold MignosiSeebold1993  Thus Sturmian words are closely related to the free group  This connection is one of the main points of the present paper  Sturmian words were generalized to arbitrary alphabets  Following an initial work by Arnoux and Rauzy ArnouxRauzy1991 and developing ideas of De Luca deLuca1997 Droubay  Justin and Pirillo introduced in DroubayJustinPirillo2001 the notion of episturmian words which generalizes Sturmian words to arbitrary finite alphabets  In this paper  we consider the extension of the results known for bifix codes maximal in the free monoid to bifix codes maximal in more restricted sets of words  and in particular the sets of factors of episturmian words  We extend most properties of ordinary maximal bifix codes to bifix codes that are maximal in a recurrent set of words  -maximal bifix codes   We show in particular that the average length of a finite -maximal bifix code of degree in a recurrent set with respect to an invariant probability distribution on is equal to  Corollary corollaryAveragelength  Our main objective is the case of the set of factors of an episturmian word  We actually work with the set of factors of a strict episturmian word  called simply a Sturmian set  The number of factors of length of a strict episturmian word over an alphabet of letters is known to be  Our main result is that a maximal bifix code of degree in a Sturmian set over an alphabet of letters is always a basis of a subgroup of index of the free group  Theorem theoremGroups  In particular  it has elements  Theorem theoremBifixd 1  Since the set of all words of length is a maximal bifix code of degree this yields a strong generalization of the previous property  In particular  every finite maximal bifix code of degree over a two letter alphabet contains exactly factors of any Sturmian word  Finally  bifix codes contained in restricted sets of words are used to study the groups in the syntactic monoid of the submonoid  Theorem newTheorem  This aspect was first considered by Sch  utzenberger in Schutzenberger1979  He has studied the conditions under which parameters linked with the syntactic monoid of a finitely generated submonoid of a free monoid can be bounded in terms of only  One of his results is that  apart from a special case where the group is cyclic  the cardinality of a group contained in is such a parameter  In Schutzenberger1979 Sch  utzenberger conjectured a refinement of his result which was subsequently proved by C  esari  This study led to the Critical Factorization Theorem that we will meet again here  Theorem theoremCriticalFactorization  The extension of the results concerning codes in free monoids to codes in a restricted set of words has already been considered by several authors  However  most of them have focused on general codes rather than on the particular class of bifix codes  In Reutenauer1986 the notion of codes of paths in a graph has been introduced  Such paths can also be viewed as words in a restricted set  The notion of a bifix code of paths has been studied in DeFelice1988 where the internal transformation is generalized  In Restivo1990 the notion of code in a factorial set of words was introduced  The definition of a code in a factorial set requires that the set of all concatenations of words in is included in  This approach was pushed further in HongShin2009  A more general notion was considered in BealPerrin2005  It only requires that and that no word of has two distinct factorizations but not necessarily that  The connection with unambiguous automata was considered later in BealPerrin2009  Codes in Sturmian sets have been studied before in CarpideLuca2005  Finally  prefix codes contained in restricted sets of words are used in PerrinRindone2003 to study the groups in the syntactic monoid of the submonoid  Our paper is organized as follows  In a first section  Section sectionFactorialSets   we recall some definitions concerning prefix-closed  factorial  recurrent and uniformly recurrent sets  in relation with infinite words  We also introduce probability distributions on these sets  In Section sectionPrefixCodes we introduce prefix codes in factorial sets  especially maximal ones  We introduce some basic notions on automata  We define the average length with respect to a probability distribution on the factorial set  In Section sectionBifixCodes we develop the theory of maximal bifix codes in recurrent sets  We generalize most of the properties known in the classical case  In particular  we show that the notion of degree and that of derived code can be defined  Theorem thmDerived  We show that  for a uniformly recurrent set any -thin bifix code contained in is finite  Theorem theoremCompletion  In the case of Sturmian sets  we prove our main results  First  a bifix code of degree maximal in a Sturmian set on a -letter alphabet has elements  Theorem theoremBifixd 1  Next  given an infinite word if there is a finite maximal bifix code of degree such that has at most factors of length in then is ultimately periodic  Corollary corollaryPeriod  The proof uses the Critical Factorization Theorem  see e g  Lothaire1983 CrochemorePerrin1991  Section sectionBasis presents our results concerning free groups  Our main result  Theorem theoremGroups  in this area states that for a Sturmian set a bifix code is a finite and -maximal bifix code of -degree if and only if it is a basis of a subgroup of index of the free group on  We finally present in Section sectionSyntacticGroups a consequence of Theorem theoremGroups concerning syntactic groups  We show that any transitive permutation group of degree which can be generated by elements is a syntactic group of a bifix code with elements  Theorem newTheorem  Many results of this paper are extensions or generalizations of results contained in BerstelPerrinReutenauer2009  We always give the reference of the corresponding result in BerstelPerrinReutenauer2009  The proofs sometimes consist in the verification that the proof of the book still holds in the more general setting  and sometimes require new and more involved developments  In order to make the paper self contained  and to avoid repetitive references to the book  we have tried to always give complete proofs 
Factorial sets
 In this section  we introduce the basic notions of prefix-closed  factorial  recurrent and uniformly recurrent sets  These form a descending hierarchy  These notions are closely related with the analogous notions for infinite words which are defined in Section subsectionRecurrentWords  In Section subsectionProbas we introduce probability distributions on factorial sets  We use the standard terminology and notation on words  in particular concerning prefixes  suffixes and factors  see Lothaire1983 for example   Let be a finite alphabet  All words considered below are supposed to be on the alphabet  We denote by the empty word  We denote by the set of all words on and by the set of nonempty words  The reversal  reversal   word reversal  of a word where are letters  is the word  In particular  the reversal of the empty word is the empty word  A set of words is closed under reversal  closed under reversal  set  if it contains the reversals of its elements  Given a set of words  we define  for a word the set by u  -1 X   y in A   mid uy in X     Next  we say that a word is a prefix of  prefix of a set  if it is a prefix of a word of  A nonempty set of words is said to be prefix-closed  prefix-closed set  if it contains the prefixes of all its elements  Symmetrically  it is said to be suffix-closed  suffix-closed set  if it contains the suffixes of all its elements  It is said to be factorial  factorial set  if it contains the factors of all its elements  The right  resp  left  order  left order   right order   order left   order right  of a word with respect to is the number of letters such that  resp   A set is said to be right essential  right essential   essential right  if it is prefix-closed and if any has right order at least  If is right essential  then for any and any integer there is a word of length such that  Symmetrically  a set is said to be left essential  left essential   essential left  if it is suffix-closed and if any has left order at least
Recurrent sets
 A set of words is said to be recurrent  recurrent set  if it is factorial and if for every there is a such that  A recurrent set is right and left essential  The set is recurrent  Let  Let be the set of words on without factor  Thus  The set is recurrent  Indeed  if then  A set is said to be uniformly recurrent  uniformly recurrent  if it is factorial and right essential and if  for any word there exists an integer such that is a factor of every word in  A uniformly recurrent set is recurrent  Let  Let be such that is a factor of any word in  Since is right essential  there is a word of length such that  Since is a factor of we have for some words  Thus  The converse of Proposition uniformImpliesRecurrent is not true as shown in the example below  The set on is recurrent but not uniformly recurrent since but is not a factor of for any
Recurrent words
 We denote by the set of factors of an infinite word  The set is factorial and right essential  An infinite word is said to be recurrent  recurrent word  if for any word there is a such that  Equivalently  each factor of a recurrent word has an infinite number of occurrences in  For any recurrent set there is an infinite word such that  Set  Since is recurrent and there is a word such that  Further  since there is a word such that  In this way  we obtain an infinite word such that  For any infinite word the set is recurrent if and only if is recurrent  Set  Suppose first that is recurrent  For any in there is a such that  Thus is recurrent  Conversely  assume that is recurrent  Let be in  Then there is a factorization with and  Since is recurrent  the word is a factor of  Set with and  Then is in  Thus is recurrent  An infinite word is said to be uniformly recurrent  uniformly recurrent word  if the set is uniformly recurrent  There exist recurrent infinite words which are not uniformly recurrent  as shown in the following example  Let be the infinite word obtained by concatenating all binary words in radix order  by increasing length  and for each length in lexicographic order  Thus  starts as follows  x ab  aaabbabb  aaaaababaabbbaababbbabbb cdots The infinite word is recurrent since every factor occurs infinitely often  However  is not uniformly recurrent since each for is a factor of thus two consecutive occurrences of say the letter may be arbitrarily far one from each other  The word is closely related to the Champernowne word Champernowne1933  We use indifferently the terms of morphism  morphism  or substitution  substitution  for a monoid morphism from into itself  Let be a morphism and assume there is a letter such that  The words for are prefixes of one another  If with then we denote by the infinite word which has all as prefixes  It is called a fix-point  fix-point of a morphism  of  Set  The Thue--Morse morphism  Thue--Morse morphism  is the substitution defined by and  The Thue--Morse word  Thue--Morse word  is the fix-point of  It is uniformly recurrent  see Lothaire2002 Example 1 5 10   We call Thue--Morse set  Thue--Morse set  the set of factors of the Thue--Morse word  An infinite word avoids  avoid   word avoiding a set  a set of words if  We denote by the set of infinite words avoiding a set  A  one sided  shift space  shift space  is a set of infinite words of the form for some  A shift space is minimal  shift space minimal   minimal shift space  if for any shift space one has or  For any infinite word we denote by the set of infinite words such that  The set is a shift space  Indeed  we have if and only if or equivalently for  The following property is standard  see for example Lothaire2002 Theorem 1 5 9   An infinite word is uniformly recurrent if and only if is minimal 
Episturmian words
 A Sturmian word  Sturmian word  is an infinite word on a binary alphabet such that the set has elements for any  Set  The Fibonacci morphism  Fibonacci morphism  is the substitution defined by and  The Fibonacci word  Fibonacci word  x abaab aba abaab abaababa abaababaabaab cdots is the fix-point of  It is a Sturmian word  see Lothaire2002 Example 2 1 1   We call Fibonacci set  Fibonacci set  the set of factors of the Fibonacci word  Episturmian words are an extension of Sturmian words to arbitrary finite alphabets  Recall that  given a set of words over an alphabet the right  resp  left  order of a word in is the number of letters such that  resp   A word is right-special  right-special word   resp  left-special  left-special word   if its right order  resp  left order  is at least  A right-special  resp  left-special  word is strict  strict right-special word   strict left-special word  if its right  resp  left  order is equal to  In the case of a -letter alphabet  all special words are strict  By definition  an infinite word is episturmian  episturmian word  if is closed under reversal and if contains  for each at most one word of length which is right-special  Since is closed under reversal  the reversal of a right-special factor of length is left-special  and it is the only left-special factor of length of  A suffix of a right-special factor is again right-special  Symmetrically  a prefix of a left-special factor is again left-special  As a particular case  a strict  strict episturmian word   episturmian word strict  episturmian word is an episturmian word with the two following properties  has exactly one right-special factor of each length and moreover each right-special factor of is strict  that is satisfies the inclusion  see DroubayJustinPirillo2001  It is easy to see that for a strict episturmian word on an alphabet with letters  the set has elements for each  Thus  for a binary alphabet  the strict episturmian words are just the Sturmian words  since a Sturmian word has one right-special factor for each length and its set of factors is closed under reversal  An episturmian word is called standard  standard episturmian word   episturmian word standard  if all its left-special factors are prefixes of  For any episturmian word there is a standard one such that  This is a rephrasing of Theorem 5 in DroubayJustinPirillo2001  Consider the following generalization of the Fibonacci word to the ternary alphabet  Consider the morphism defined by and  The fix-point f  omega a  abac aba abac ab abac aba abac abac aba abac ab cdots is the Tribonacci word  Tribonacci word   It is a strict standard episturmian word  see JustinVuillon2000  The following is  in the case of Sturmian words  Proposition 2 1 25 in Lothaire2002  The general case results from Theorems 2 and 5 in DroubayJustinPirillo2001  An episturmian word is uniformly recurrent and is minimal  The converse is false as shown by the following example  The Thue--Morse word of Example exampleMorse is not Sturmian  Indeed  it has four factors of length  We recall now some notions and properties concerning episturmian words  A detailed exposition with proofs is given in JustinVuillon2000 DroubayJustinPirillo2001 JustinPirillo2002 JustinPirillo2004  See also the survey paper GlenJustin2009  For denote by the morphism of into itself  called elementary morphism  elementary morphism   morphism elementary   defined by  psi a b   a b	 if
 a	 otherwise Let be the morphism from into the monoid of endomorphisms of which maps each to  For we denote by the image of by the morphism  Thus  for three words we have  A palindrome  palindrome word  is a word which is equal to its reversal  Given a word we denote by the palindromic closure  palindromic closure  of  It is  by definition  the shortest palindrome which has as a prefix  The iterated palindromic closure  iterated palindromic closure  of a word is the word defined recursively as follows  One has and for and one has  Since is a proper prefix of it makes sense to define the iterated palindromic closure of an infinite word as the infinite word which is the limit of the iterated palindromic closure of the prefixes of  Justin s Formula  Justin s Formula  is the following  For every words and one has  Pal uv   psi u  Pal v   Pal u     This formula extends to infinite words  if is a word and is an infinite word  then There is a precise combinatorial description of standard episturmian words  see e g  JustinVuillon2000 GlenJustin2009  An infinite word is a standard episturmian word if and only if there exists an infinite word where the are letters  such that s  lim  n o infty  u n    where the sequence is defined by  Moreover  the word is episturmian strict if and only if every letter appears infinitely often in  The infinite word is called the directive word  directive word  of the standard word  The description of the infinite word can be rephrased by the equation s  Pal  Delta     As a particular case of Justin s Formula  one has The words are the only prefixes of which are palindromes  The Fibonacci word of Example exampleFibonacci is a standard episturmian word  It has the directive word that is GlenJustin2009  The Tribonacci word of Example exampleTribonacci has the directive word JustinVuillon2000  The corresponding sequence starts with  Observe that so that indeed as claimed in  eqre fEquationMagique   Let and  Then  we have  By Justin s Formula JustinInfini the limit is the word where is the Fibonacci word on  This means that is obtained from by inserting a letter before every letter of  The word is not strict  Indeed  the letters and are not right-special and the letter is not strict right special since is not a factor  Let and  It is easily checked that is the periodic word  The only right-special factors of this word are and  GlenJustin2009
Probability distributions
 Let be a prefix-closed set of words  For denote by the set  A right probability distribution  right probability distribution   probability distribution right  on is a map such that em  upshap e i    em  upshap e ii    for any  For a right probability distribution on and a set we denote  See BerstelPerrinReutenauer2009 for the elementary properties of right probability distributions  Note in particular that for any and one has  as a consequence of condition  ii   In particular  if is a right probability distribution on then for all  The distribution is said to be positive  positive probability distribution   probability distribution right  on if for any  Symmetrically  for a suffix-closed set a left probability distribution  left probability distribution   probability distribution left  is a map satisfying condition  i  above and em  iii   for any with  When is factorial  an invariant probability distribution  invariant probability distribution   probability distribution invariant  is both a left and a right probability distribution  For any right essential set of words  there exists a positive right probability distribution on  Consider the map defined for by  proba w   fra c1  d 0d 1 cdots d  n-1   where for  Since is right essential  for  By convention   Let us verify that is a right probability distribution on  Indeed  let  The set is nonempty  Let we have  Since we obtain that satisfies condition  ii  and thus it is a right probability distribution  It is clearly positive  We will now turn to the existence of positive invariant probability distributions  A topological dynamical system  topological dynamical system   dynamical system topological  is a pair of a compact metric space and a continuous map from into  Any shift space becomes a topological dynamical system when it is equipped with the shift map defined by  Indeed  we consider as a metric space for the distance defined for and by if and where is the least integer such that otherwise  A subset of a topological dynamical system is said to be stable under  stable dynamical system   dynamical system stable  or stable for short if  A stable subset is also called  topologically  invariant  The following property is well-known  although usually stated for two sided-infinite words  see for example Proposition 1 5 1 in Lothaire2002  The shift spaces are the stable and closed subsets of  It is clear that a shift space is both closed and stable  Conversely  let be closed and stable under the shift  Let be the set of words which are not factors of words of  Then  Indeed  if then and thus  Conversely  let  Let be the prefix of length of  Since there is an infinite word such that  Since is stable under the shift  we may assume that is a prefix of  The sequence converges to  Since is closed  this forces  Let be a metric space  The family of Borel subsets  Borel subsets  of is the smallest family of subsets of containing the open sets and closed under complement and countable union  A function from to is said to be countably additive  countably additive function  if for any sequence of pairwise disjoint Borel subsets of  A Borel probability measure  Borel probability measure  on is a function from into which is countably additive and such that  Let be a topological dynamical system  A Borel probability measure on is said to be invariant  Borel probability measure invariant   invariant Borel probability measure  if for any  Note that since is continuous  and thus is well defined  The following result is from  For any topological dynamical system  there exist invariant Borel probability measures  A dynamical system is said to be minimal  minimal dynamical system   dynamical system minimal  if the only closed stable subsets of are and  Note that  by Proposition propShiftSpaces this definition is consistent with the definition of a minimal shift space  A Borel probability measure on is positive  Borel probability measure positive   positive Borel probability measure  if for every nonempty open set  Any invariant Borel probability measure on a minimal topological dynamical system is positive  Let be an invariant Borel probability measure on the topological dynamical system  Let be a nonempty open set  Let and  Since is open and is continuous  each is open  Thus is open and is closed  The set is also stable  Indeed  if for we had then there would be an integer such that  Thus a contradiction  Thus  Since is minimal  this implies that or  Since is nonempty  we have and thus  Since is invariant  we have and thus for all  Hence we cannot have since it would imply a contradiction since  For any recurrent set there exists an invariant probability distribution on  When is uniformly recurrent  such a distribution is positive  Let be a recurrent set  By Proposition propExists there is a recurrent infinite word such that and if is uniformly recurrent  then is uniformly recurrent  By Theorem thKrylovBogolioubov there is an invariant Borel probability measure on  Let be the map from to defined by  Let us verify that is an invariant probability distribution  Indeed  one has  Next  for  sum  a in S w   proba wa   sum  a in S w   mu waA  N cap S   mu wA  N cap S   proba w   In the same way  sum  a in P w   proba aw   sum  a in P w   mu awA  N cap S   mu  sigma  -1  wA  N cap S    mu wA  N cap S   proba w   If is uniformly recurrent  by Proposition propMinimal the shift space is minimal  By Proposition propMinimalisPositive the measure is positive  Since is a nonempty open set for any we have and thus is positive  In some cases  there exists a unique invariant probability distribution on the set  A morphism is primitive  primitive morphism   morphism primitive  if there exists an integer such that  for all the letter appears in  If is a primitive morphism and if starts with the letter for some then is a fix-point of and there is a unique invariant probability distribution on the set  Moreover  this distribution is positive  We illustrate this result by the following examples  Let be the Fibonacci set  see Example exampleFibonacci  Since the morphism defined by and is primitive  there is a unique invariant probability distribution on  Its values on the words of length at most are shown on Figure figProbaFibo with   hbt  sse tNadjust wh   100 50   node 1  0 25      node a  15 35     node b  15 15      node aa  30 45     node ab  30 30      node ba  30 10      node aab  50 45      node aba  50 30      node baa  50 15     node bab  50 5      node aaba  70 45      node abaa  70 35     node abab  70 25      node baab  70 15      node baba  70 5     rawedge 1 a     rawedge ELside r  1 b     rawedge a aa     rawedge ELside r  a ab     rawedge aa aab     rawedge ab aba     rawedge aab aaba     rawedge aba abaa     rawedge ELside r  aba abab     rawedge ELside r  b ba     rawedge ba baa     rawedge ELside r  ba bab     rawedge baa baab     rawedge bab baba     The invariant probability distribution on the Fibonacci set  The values of can be obtained as follows  see Queffelec2010  The vector is an eigenvector for the eigenvalue of the -matrix defined by  Here  we have M  1	1
 1	0 This implies  The other values can be computed using conditions  ii  and  iii  of the definition of an invariant probability distribution  Let be the Thue--Morse set  see Example exampleMorse  Since the Thue-Morse morphism is primitive  there is a unique invariant probability distribution on  Its values on the words of length at most are shown on Figure figProbaMorse   hbt  sse tNadjust wh   100 63   node 1  0 32      node a  15 50     node b  15 15      node aa  30 60     node ab  30 40      node ba  30 23     node bb  30 4      node aab  45 60      node aba  45 45     node abb  45 35      node baa  45 28     node bab  45 18      node bba  45 4      node aaba  60 63     node aabb  60 56      node abaa  60 49     node abab  60 42      node abba  60 35      node baab  60 28      node baba  60 21     node babb  60 14      node bbaa  60 7     node bbab  60 0     rawedge 1 a     rawedge 1 b     rawedge a aa     rawedge a ab     rawedge aa aab     rawedge ab aba     rawedge ab abb     rawedge aab aaba     rawedge aab aabb     rawedge aba abaa     rawedge aba abab     rawedge abb abba     rawedge b ba     rawedge b bb     rawedge ba baa     rawedge ba bab     rawedge baa baab     rawedge bab baba     rawedge bab babb     rawedge b bb     rawedge bb bba     rawedge bba bbaa     rawedge bba bbab     The invariant probability distribution on the Thue--Morse set 
Prefix codes in factorial sets
 In this section  we study prefix codes in a factorial set  We will see that most properties known in the usual case are also true in this more general situation  Some of them are even true in the more general case of a prefix-closed set instead of a factorial set  In particular  this holds for the link between prefix codes and probability distributions  Proposition propMaxPrefixCode  Recall that a set of nonempty words over an alphabet is a code  code  if the relation x 1 cdots x n y 1 cdots y m with and implies and for  For the general theory of codes  see BerstelPerrinReutenauer2009
Prefix codes
 The prefix order  prefix order   order prefix  is defined  for by if is a prefix of  Two words are prefix-comparable  prefix-comparable words   word prefix-comparable  if one is a prefix of the other  Thus and are prefix-comparable if and only if there are words such that or  equivalently  if and only if  The suffix order  order suffix   and the notion of suffix-comparable words  are defined symmetrically  A set of nonempty words is a prefix code  prefix code   code prefix  if any two distinct elements of are incomparable for the prefix order  A prefix code is a code  The dual notion of a suffix  suffix code   code suffix  code is defined symmetrically with respect to the suffix order  The submonoid generated by a prefix code satisfies the following property  if then  Such a submonoid of is said to be right unitary  right unitary submonoid   One can show that conversely  any right unitary submonoid of is generated by a prefix code  see BerstelPerrinReutenauer2009  The symmetric notion of a left unitary submonoid is defined by the condition implies  We denote by the characteristic series  characteristic series  of a set  By definition  for any   u X  x   1	 if
 0	 otherwise The following is Proposition 3 1 6 in BerstelPerrinReutenauer2009  Let be a prefix code and let  Then
Automata
 We recall the basic results on deterministic automata and prefix codes  see BerstelPerrinReutenauer2009 for a more detailed exposition   We denote a deterministic automaton with as set of states  as initial state and as set of terminal states  For and we denote if there is a path labeled from to the state and otherwise  The set recognized  recognized by an automaton  by the automaton is the set of words such that  A set of words is rational  rational set  if is recognized by a finite automaton  All automata considered in this paper are deterministic and we call them simply automata  The automaton is trim  automaton trim   trim automaton  if for any there is a path from to and a path from to some  An automaton is called simple  automaton simple   simple automaton  if it is trim and if it has a unique terminal state which coincides with the initial state  An automaton is complete  automaton complete   complete automaton  if for any state and any letter one has  For a set we denote by the minimal automaton  automaton minimal   minimal automaton  of  The states of are the nonempty sets for  The initial state is the set and the terminal states are the sets for  Let be a prefix code  Then there is a simple automaton that recognizes  Moreover  the minimal automaton of is simple  Let be a prefix code and let be the set of proper prefixes of  The literal automaton  literal automaton   automaton literal  of is the simple automaton with transitions defined for and by p cdot a  p a	 if    
 1	 if    
 ptyse t	 otherwise  One verifies that this automaton recognizes  Let be an automaton  For we denote the partial map from to defined by if  The transition monoid  transition monoid   monoid transition  of is the monoid of partial maps from to of the form for
Maximal prefix codes
 Let be a subset of  A set is right dense  right dense set  in or right -dense  if any is a prefix of  A set is right complete  right complete set  in or right -complete  if is right dense in that is if every word in is a prefix of  A prefix code is maximal  F-maximal code  -maximal code  in or -maximal  if it is not properly contained in any other prefix code  The notion of an -maximal suffix code is symmetrical  The following propositions are extensions of Propositions 3 3 1 and 3 3 2  and of Theorem 3 3 5 in BerstelPerrinReutenauer2009  Let be a subset of  For any prefix code the following conditions are equivalent  em  upshap e i    Every element of is prefix-comparable with some element of em  upshap e ii    is an -maximal prefix code   i  implies  ii   Any word is prefix-comparable with some word of  This implies that if then is no longer a prefix code  Thus is an -maximal prefix code   ii  implies  i   Assume that is not prefix-comparable to any word in  Then is prefix  and is not an -maximal prefix code  Let be a factorial subset of  For any set of nonempty words  the following conditions are equivalent  em  upshap e i    Every element of is prefix-comparable with some element of em  upshap e ii    is right -dense  em  upshap e iii    is right -complete   i  implies  ii   Let  Let be prefix-comparable with  Then there exist such that  Thus is right -dense   ii  implies  iii   Consider a word  Let us show that is a prefix of  Since is right -dense  one has for some word and  If is a prefix of there is nothing to prove  Otherwise  is a proper prefix of  Thus for some and  Since is in and since is factorial  we have  Since we have  Arguing by induction  the word is a prefix of  Thus is a prefix of   iii  implies  i   Let  Then is a prefix of and consequently is prefix-comparable with a word in  The propositions have a dual formulation  replacing prefix by suffix  and right by left  The set is a maximal prefix code in the Fibonacci set since is right -dense  The following is a generalization of Propositions 3 7 1 and 3 7 2 in BerstelPerrinReutenauer2009  Let be a right essential set  Let be a positive right probability distribution on  Any prefix code satisfies  If is finite  it is -maximal if and only if  Assume first that is finite  Let be the maximal length of the words in  We have and the terms of the union are pairwise disjoint  Thus  using Equation  eqre feqProbas  If is maximal in any word in has a prefix in  Thus we have equality in  eqre feqX  and thus also in  eqre feqPi   This shows that  The converse is clear since is positive on  If is infinite  then for any finite subset of  Thus  The statement has a dual for a suffix code included in a factorial set with a positive left probability distribution on  Let be the Fibonacci set  The set is a maximal prefix code  Example exaba  One has where is defined in Example exProba  We will use the following result in the proof of Proposition propositionInternalTransformation  Let be a right essential subset of and let be a right essential subset of  For any finite -maximal prefix code the set is a finite -maximal prefix code  Set  The set is clearly a finite prefix code  We show that every is prefix-comparable with some word in  This will imply that is -maximal by Proposition propositionPrefixGlobal  Let  Since is right essential  there are arbitrary long words such that  Choose the length of larger than the maximal length of the words of  Since is an -maximal prefix code  has a prefix in  This prefix is in since  Thus is prefix-comparable to  The following example shows that Proposition propositionFinitePrefixCodes is false for infinite prefix codes  Let be a right essential set with and let be a word which is not in  Let be the prefix code of words in ending with and having no other occurrence of  is a maximal prefix code  and is not -maximal  We will use later the following result on transformations of prefix codes  It is adapted from Proposition 3 4 9 in BerstelPerrinReutenauer2009  Let be a factorial set and let be an -maximal prefix code  Let be a nonempty prefix of and set  The set is an -maximal prefix code  It is clear that is a prefix code  To show that it is -maximal  we apply Proposition propositionPrefixGlobal and prove that every word is prefix-comparable with a word of  So consider a word  Since is -maximal  is prefix-comparable with a word of  Thus is prefix-comparable with a word of or it is prefix-comparable with a word of  In the second case  either is a prefix of a word with or has as a prefix  Consequently  is prefix-comparable with  This proves that is prefix-comparable with a word of  Proposition propositionOperation1 has a dual formulation for suffix codes 
Average length
 Let be a right essential set and let be a right probability distribution on  Let be a prefix code such that  The average length  average length  of with respect to is the sum mbda X   sum  x in X |x| proba x     Let be a right essential set and let be a positive right probability distribution on  Let be a finite -maximal prefix code and let be the set of proper prefixes of  Then and  We already know that by Proposition propMaxPrefixCode  Let us show that for any Let indeed be an integer larger than the lengths of the words of  Then by Equation  eqre feqProbas    Since is an -maximal prefix code  each word of has a prefix in and conversely  each word in which has as a prefix is itself a prefix of  Thus pA n cap F  cup  x in pA   cap X xA  n |p|-|x|  cap F    Since this proves Equation  eqre feqProbas2   By Equation  eqre feqProbas2   one gets  sum  p in P  proba p   sum  p in P  sum  x in pA   cap X  proba x    sum  x in X  sum  p in P x in pA    proba x   sum  x in X |x| proba x     Thus  proba P   sum  p in P  proba p   sum  x in X |x| proba x   mbda X     A dual statement of Proposition propositionP holds for a suffix code and its set of proper suffixes  for a positive left probability distribution  Let be the Fibonacci set and let  We have already seen in Example exabapi that is an -maximal prefix code and that where is the unique invariant probability distribution on defined in Example exProba  We have  On the other hand the set of proper prefixes of is and thus
Bifix codes in recurrent sets
 In this section  we study bifix codes contained in a recurrent set  Since itself is a recurrent set  it is a generalization of the usual situation  We will see that all results on maximal bifix codes can be generalized in this way  In particular  the notions of degree  of kernel and of derived code can be defined in this more general framework 
Parses
 Recall that a set of nonempty words is a bifix code  code bifix   bifix code  if any two distinct elements of are incomparable for the prefix order and for the suffix order  A parse  parse of a word  of a word with respect to a set is a triple such that with and  Let be a factorial set and let be a set  For any factorization of there is a parse of with and  Since there exist  by Proposition propositionCharPrefix words and such that  Symmetrically  there exist and such that  Then is a parse of which satisfies the conditions of the statement  The number of parses of a word with respect to is denoted by  The function is the parse enumerator  parse enumerator  with respect to  The indicator  indicator  of a set is the series defined for by  Let  Then  The following is a reformulation of Proposition 6 1 6 in BerstelPerrinReutenauer2009  Let be a factorial set and let be a prefix code  For every word the number is equal to the number of prefixes of which have no suffix in  For every prefix of which is in there is a unique parse of of the form  Since any parse is obtained in this way  the statement is proved  Proposition propInterpretations has a dual statement for suffix codes  Note that  as a consequence of Proposition propInterpretations we have for two prefix codes and for all words Indeed  a word without suffix in is also a word without suffix in  Let be a prefix code and let  Then If is bifix  one has Set  Let  By definition of the indicator  we have  Since is prefix  we have by Proposition propositionCharPrefix the equality  Thus we obtain  note that this is actually equivalent to Proposition propInterpretations  Multiplying both sides on the right by we obtain Equation  eqre feqLS   If is suffix  we have by the dual of Proposition propositionCharPrefix the equality  This gives Equation  eqre feqLB  by multiplying both sides of Equation  eqre feqLS  on the left by  The following is Proposition 6 1 11 in BerstelPerrinReutenauer2009  A function is the parse enumerator of some bifix code if and only if it satisfies the following conditions  em  upshap e i    For any and em  upshap e ii    For any and em  upshap e iii    For any and em  upshap e iv        The following is a reformulation of Proposition 6 1 12 in BerstelPerrinReutenauer2009  Let be a prefix code  For any and one has This follows directly from Proposition propInterpretations  Proposition propositioneqL has a dual for suffix codes expressing in terms of  Recall also that by Proposition 6 1 8 in BerstelPerrinReutenauer2009 for a bifix code and for all such that one has Moreover  if and then the inequality is strict  that is 
Maximal bifix codes
 Let be set of words  A set is said to be thin  thin set  in or -thin  if there exists a word of which is not a factor of a word in  The following example shows that there exist a uniformly recurrent set and a bifix code which is not -thin  Let be the Thue--Morse set  which is the set of factors of a fix-point of the substitution defined by  see Example exampleMorse  Set for  Note that where is the substitution defined by and  Note also that if and only if  Consider the set  We have  Indeed  for implies that and thus  Next is a bifix code  Indeed  for begins with and thus cannot have as a prefix  Similarly  since ends with or with it cannot have as a suffix  Finally any element of is a factor of a word in  Indeed  any element of is a factor of some and thus of  A simpler proof uses Theorem theoremCompletion proved later  An internal factor  internal factor   factor internal   word internal factor  of a word is a word such that with nonempty  Let be a factorial set and let be a set  Denote by I X   w in A   mid A  wA   cap X ne ptyset  the set of internal factors of words in  When is right essential and left essential  then is -thin if and only if  Indeed  the condition is necessary  Conversely  if is in let be such that  Since cannot be a factor of a word in it follows that is -thin  We say that a bifix code is maximal  F-maximal bifix code  -maximal bifix code  in or -maximal  if it is not properly contained in any other bifix code  The following is a generalisation of Proposition 6 2 1 in BerstelPerrinReutenauer2009  Let be a recurrent set and let be an -thin set  The following conditions are equivalent  em  upshap e i    is an -maximal bifix code  em  upshap e ii    is a left -complete prefix code  em  upshap e ii     is a right -complete suffix code  em  upshap e iii    is an -maximal prefix code and an -maximal suffix code  As a preparation for the proof of Theorem theoremEquivMax we introduce the following notation  Let be a recurrent set and let  A factorization  factorization of a word  of a word is a pair of words such that  We denote by the set of factorizations of  Let be the set of pairs of words such that and is not an internal factor of  We define for each pair a relation on the set as follows  For one has if and only if the pair satisfies one of the following conditions  see Figure figureVarphi  em  i   for some em  ii   with and for is a proper prefix of and is a proper suffix of  Since the condition  i  is equivalent to  This means that both conditions are symmetric for reading from left to right or from right to left   hbt  sse tNadjust wh AHnb 0   90 10  -10 0   node p  -10 0     node Nframe n Nadjustdist 0  x1  10 0     node v  20 0     node Nframe n Nadjustdist 0  x2  25 0     node Nframe n Nadjustdist 0  xn  45 0     node q  50 0     node Nframe n Nadjustdist 0  x   60 0     node end  80 0    rawedge curvedepth 5  x1 x2     rawedge curvedepth 5  x2 xn     rawedge curvedepth 5  xn x      rawedge ELside r  p v     rawedge ELside r  v q     rawedge q x      rawedge x  end     rawedge ELside r  q end     rawedge p x1     rawedge x1 v     The relation  case  ii    We prove a series of lemmas concerning the relations  see Exercise 6 2 1 in BerstelPerrinReutenauer2009  Let be a recurrent set and let be an -thin set  If is a prefix code  then for all pairs the relation is a partial function from into itself  that is Conversely  if is an -maximal suffix code  and if  eqre fequationPartial  holds for all pairs then is a prefix code  Define the transpose  transpose of a relation  of the relation by the condition if  Then  eqre fequationPartial  expresses the fact that the transpose is injective   medskip Assume first that is a prefix code  For let be three factorizations of such that  We prove that  By definition  the following cases may occur for  em  1   and with em  2   with and with and and moreover is a proper prefix of and is a proper suffix of em  3   with and with and and moreover is a proper prefix of and is a proper suffix of em  4   and with and moreover is a proper prefix both of and of is a proper suffix of and is a proper suffix of   1  Assume that with  Since and are prefixes of they are prefix-comparable  Thus and are also prefix-comparable  Since is a prefix code  it follows that whence and   2  We show that this case is impossible  Indeed  is a prefix of  by  and is a proper prefix of thus is a proper prefix of and this is impossible because is a prefix code  The same argument holds in the symmetric case  3    4  Since the words and are prefix-comparable  We may suppose that  see Figure figureVarphi2  Since are in and is a prefix code  we have  Since is a code  the decompositions coincide  Consequently   By hypothesis  is a proper suffix of  This forces and hence   hbt  sse tNadjust wh AHnb 0   100 18  -15 -10   node u1  -10 0     node Nframe n Nadjustdist 0  s  10 0     node v  25 0     node u2  40 0     node Nframe n Nadjustdist 0  r  50 0     node Nframe n Nadjustdist 0  q  60 0     node end  80 0    rawedge ELside r  u1 v     rawedge ELside r  v u2     rawedge u1 s     rawedge s v     rawedge u2 q     rawedge q end     rawedge ELside r ELpos 60  u2 end     rawedge ELside r  u2 r     rawedge curvedepth 7  s q    rawbpedge s -70 12 r -110 12    rawedge curvedepth -7 linecolor red  r q     The factorizations and with  Conversely  assume that is an -maximal suffix code and that it is not a prefix code  Let be distinct words in such that is a prefix of  Set with  Since is -thin  there is a word  Since is recurrent  there is a word such that  Let  Then  Let be a word such that  Set  Thus  see Figure figLemma211  By the dual of Equation  eqre feqX-1   there exist and such that  Since is left -complete  is a proper suffix of a word in  Since is a prefix of  Thus or  In the latter case  set with  Since one of the following two cases holds  em  1   with em  2   there is an with such that with and  In case  1   consider the three factorizations of  Since we have  We have and thus  this is case  ii  of the definition with  Next  with and where is a proper suffix of  Hence  Thus  is not a partial function  In case  2   let and let be as above  We have whence  Next  and is a proper suffix of  Thus  Since is not a partial function   hbt  sse tNadjust wh AHnb 0   100 25  0 -5   node t  40 15     node x   50 15     node r   60 15     node r    70 15     node w  80 15    node wend  100 15    rawedge t x      rawedge x  r     rawedge r  r       rawedge r   w     rawedge w wend     rawedge curvedepth 3  x  r      rawedge curvedepth -5 ELside r ELpos 60  x  r        node Nframe n Nadjustdist 0  z  10 0     node ul  0 0     node v  40 0     node Nframe n Nadjustdist 0  x b  50 0     node ur  60 0     node Nframe n Nadjustdist 0  r  b  70 0     node Nframe n Nadjustdist 0  p    90 0     node Nframe n Nadjustdist 0  p   85 0     node end  100 0    rawedge ul z     rawedge curvedepth 5  z x b     rawedge ELside r  ul v     rawedge ELside r  v ur     rawedge ELpos 40  ur end     rawedge dash  0 2 0 5 0  t v    rawedge dash  0 2 0 5 0  r  ur    rawedge dash  0 2 0 5 0  x  x b    rawedge dash  0 2 0 5 0  r   r  b    is not a partial function  Lemma lemmaBijection1 has a dual formulation for suffix codes  if is a suffix code  then for all pairs the relation is injective  if then  Conversely  if is an -maximal prefix code  and if this implication holds for all pairs then is a suffix code  Recall that a set is right -complete if any word of is a prefix of  Let be a recurrent set and let be an -thin set  The set is right -complete if and only if  for all pairs the relation contains a total function from into itself  that is for every there exists such that  Assume first that is right -complete  Let be such that  Let  Suppose first that has a prefix in  Let with  Thus  Let and  Then  Suppose next that has no prefix in  Since is right -complete  there exists a word such that with  Let be the smallest integer such that is a prefix of  Let be the prefix of such that  Since is a proper suffix of  The word is a prefix of since is not an internal factor of  Define the factorization of by  Since has no prefix in the word is a proper prefix of  Therefore   This shows that contains a total function  Conversely  assume that for all the relation contains a total function from into itself  We show that any is prefix-comparable with a word of  By Proposition propositionGlobal this implies that is right -complete  Let  Since is -thin  the set is nonempty  Let and let be such that  Set  Note that  Let be such that  Then  Set  Since contains a total function  there is a factorization of such that  If then has the prefix in the word is prefix-comparable with and we obtain the conclusion  Otherwise  we have with and is a prefix of whence our conclusion again  Lemma lemmaBijection2 has a dual formulation for left -complete sets  the set is left -complete if and only if  for all pairs the transpose of the relation contains a total function from into itself  Let be a recurrent set and let be an -thin and -maximal prefix code  Then is a suffix code if and only if it is left -complete  Since is an -maximal prefix code  by Lemmas lemmaBijection1 and lemmaBijection2 for any pair the relation is a total function from into itself  Assume first that is a suffix code  Then  by the dual of Lemma lemmaBijection1 for any pair the function from into itself is injective  Since is a finite set  is also surjective for any pair  This implies by the dual of Lemma lemmaBijection2 that is left -complete  Assume conversely that is left -complete  By the dual of Lemma lemmaBijection2 the function maps onto itself for every pair  This implies as above that it is also injective  By the dual of Lemma lemmaBijection1 and since is an -maximal prefix code  is a suffix code  Proposition lemmaBijection has a dual formulation for an -maximal suffix code   medskip We first show that  i  implies  ii   If is an -maximal suffix code  then is left -complete and thus condition  ii  is true  Assume next that is an -maximal prefix code  Since is suffix  by Proposition lemmaBijection it is left -complete and thus  ii  holds  Finally assume that is neither an -maximal prefix code nor an -maximal suffix code  Let be such that is prefix and is suffix  Since is recurrent  there is a word such that  Then is bifix and thus we get a contradiction  The proof that  i  implies  ii   is similar   ii  implies  iii   Consider the set  It is a suffix code by definition  It is prefix since it is contained in  It is left -complete  Indeed  one has and thus is left -dense by the dual of Proposition propositionGlobal  Hence is an -maximal suffix code  By the dual of Proposition lemmaBijection the set is right -complete  Thus is an -maximal prefix code  This implies that and thus that is an -maximal prefix code and an -maximal suffix code  The proof that  ii   implies  iii  is similar  It is clear that  iii  implies  i   Let and let be the set of words without factor  Example exampleGolden  The set is a finite -maximal bifix code  As an example of computation of the relation note that for and we have with  The function is the cycle and fixes  The following example shows that Theorem theoremEquivMax is false if is not recurrent  Let  Then is an -maximal prefix code  It is not a suffix code but it is left -complete as it can be easily verified  Let be a factorial set  The - degree  F-degree  -degree   denoted of a set is the maximal number of parses of words of with respect to that is d F X   max  w in F    s X w     The -degree of a set is finite or infinite  The -degree is called the degree  degree   and is denoted  Observe that and that  The following is a generalization of Theorem 6 3 1 in BerstelPerrinReutenauer2009  Let be a recurrent set and let be a bifix code  Then is an -thin and -maximal bifix code if and only if its -degree is finite  In this case  Assume first that is an -thin and -maximal bifix code  Since is -thin  is not empty  Let and  Since is recurrent  there is a word such that  Since is prefix  by Proposition propInterpretations the number of parses of is equal to the number of prefixes of which have no suffix in  Since is left -complete  the set of words in which have no suffix in coincides with the set of words which are proper suffixes of words in  Since is not an internal factor of a word in any prefix of which is in is a prefix of  Thus  Since by Equation  eqre feqL1   we get  This shows that is bounded  and thus that the -degree of is finite  Moreover  this shows that is contained in the set of words of with maximal value of  Conversely  consider  Then there exists and such that  Then by Equation  eqre feqLi  and thus is not maximal in  This proves Equation  eqre feqH   Conversely  let be a word with  For any nonempty word such that we have  Indeed  set with and  Then by Equation  eqre feqL1   This implies  By the dual of Equation  eqre feqL  we obtain that  This implies first that is -thin and next that is right -dense  Indeed suppose that is an internal factor of a word in  Let be such that  Since the previous argument shows that a contradiction  Thus  This shows that is -thin  Next  and since is recurrent  for any there is a word such that  Then by using again the above argument  Thus is right -dense and is an -maximal bifix code by Theorem theoremEquivMax  Let be the Fibonacci set  The set is a finite bifix code  Since it is finite  it is -thin  It is an -maximal prefix code as one may check on Figure figProbaFibo  Thus it is  by Theorem theoremEquivMax an -thin and -maximal bifix code  The parses of the word are and  Since is not in one has  Let be the Fibonacci set  The set is a bifix code  It is -maximal since it is right -complete  see Figure figProbaFibo  It has -degree  Indeed  the word has three parses and and it is in  The following result establishes the link between maximal bifix codes and -maximal ones  Let be a recurrent set  For any thin maximal bifix code of degree the set is an -thin and -maximal bifix code  One has with equality when is finite  Recall that  Thus is finite and by Theorem theoremDegree is an -thin and -maximal bifix code  If is finite  then each word which is in and is longer than the longest words in has parses  Thus whence  The set is a maximal bifix code of degree 2  Let be the Fibonacci set  Then  see Figure figProbaFibo  As another example  let  The set is a finite maximal bifix code of degree  see BerstelPerrinReutenauer2009  Then  see Figure figProbaFibo  Let be the Thue--Morse set  Consider again  Then is a finite -maximal bifix code of -degree  see Figure figProbaMorse  The following examples show that a strict inequality can hold in Theorem proposition1  The second example shows that this may happen even if all letters occur in the words of  Let and let  The set is a maximal bifix code of degree  Let  Then is a recurrent set  We have  The -degree of is  Let and let be the maximal bifix code of degree with kernel  Let be the Fibonacci set  Since is an -maximal bifix code  Since and is -maximal  one has  Next and Theorem proposition1 imply that  Thus and
Derivation
 We first show that the notion of derived code can be extended to -maximal bifix codes  The following result generalizes Proposition 6 4 4 in BerstelPerrinReutenauer2009  The kernel  kernel  of a set of words is the set of words in which are internal factors of words in  We denote by the kernel of  Note that  Let be a recurrent set  Let be a bifix code of finite -degree  Set and  Let and  Then the set is a bifix code of -degree  The code is called the derived  derived code   code derived  code of with respect to or -derived code  The proof uses two lemmas  Let be the set of proper prefixes of and let be the set of proper suffixes of  One has and  By Theorem theoremDegree the parse enumerator of is bounded on and is the set of words in with maximal value  Let be in with and  Since we have  Thus  by Proposition propositioneqL does not have a suffix in  Since is left -dense  this implies that is a proper suffix of a word in  Thus is in  The proof that is symmetrical  For any the shortest prefix of which is not in is in  Since we have  Let be the shortest prefix of which is not in or  equivalently such that  Let us show that  First  is a proper prefix of  Set indeed with and  Since we have by Equation  eqre feqL    Thus and is a prefix of  Since we have  Set with and  By definition of we have  Thus  Next  set with and  Since we have by the dual of Equation  eqre feqL    Thus is in  This shows that  Thus we conclude that  There is a dual of Lemma lemmaDeriv2 concerning the shortest suffix of a word in  Proof of Theorem thmDerived  We first prove that is a prefix code  Suppose first that is a prefix of a word in  By Lemma lemmaDeriv a word in is a proper prefix of  Thus would be a proper prefix of which is impossible since is prefix  Suppose next that a word of is a prefix of a word in  Since is in it follows that is in a contradiction  Finally  no word can be a proper prefix of another word in otherwise with  Therefore  since by Lemma lemmaDeriv there is such that  Consequently  a contradiction  Thus is a prefix code  To show that it is -maximal  it is enough to show that any word in has a prefix in  Consider indeed  If is in then  Otherwise  let be the shortest prefix of which is not in  By Lemma lemmaDeriv2 we have  Thus is an -maximal prefix code  A symmetric argument shows that is an -maximal suffix code  Let us show that  We first note that  Indeed  let be such that is maximal on  If were an internal factor of a word then by Equation  eqre feqLi  which contradicts our assumption  Thus  This shows that is not an -maximal bifix code and thus that  Consider  Since is empty  and since cannot be in  Thus the number of parses of with respect to is  Let be the set of proper prefixes of  We show that has suffixes which are in  This will show that by the dual of Proposition propInterpretations  Since we have  Thus has suffixes in  One of them is itself since  Let be a proper suffix of which is in  Let us show that does not have a prefix in  Indeed  arguing by contradiction  assume that is a prefix of  We cannot have since is a proper prefix of a word in  We cannot have either  Indeed  since is in is in and thus also  Thus cannot have a prefix in  Since is an -maximal prefix code  this implies that is a proper prefix of  Thus  the proper suffixes of which are in are in   QED Let be the Fibonacci set  Let  The set is an -thin and -maximal bifix code of -degree 2  see Example exampleBifixDegree2  We have and  Thus  The following is a generalization of Proposition 6 3 14 in BerstelPerrinReutenauer2009  Let be a recurrent set  Let be a bifix code of -degree  Let be the set of proper suffixes of and set  The set is an -maximal prefix code and the set is the set of proper suffixes of the derived code  The proof uses the following lemma  Let be a recurrent set  Let be an -thin and -maximal bifix code  Let be the set of proper suffixes of and set  For any the longest prefix of which is in is not in  Let be the longest prefix of which is in  Set  Let us show that for any prefix of we have  It is true for  Assume that it is true for and let be the letter such that is a prefix of  Since we have  Thus by Equation  eqre feqL   this implies  Thus  We conclude that  Since is in and since is the set of words in with maximal value of this implies that  This lemma has a dual statement for the longest suffix of a word in which is in  Set  Let us first show that is prefix  Assume that  Since there is a nonempty word such that  Since this forces  Thus is prefix  We show next that is right -dense  Consider and let  Since is recurrent  there exists such that  Let be the longest word of which is a prefix of  By Lemma lemmaMaxSinH we have  Thus and  This shows that is right -dense  Let us now show that the set of proper suffixes of the words of is  Let be a proper suffix of a word  If then is in  Suppose next that  Since by Lemma lemmaDeriv we have  Furthermore  since we have  This shows that  Conversely  let be in  Let be such that is a proper suffix of  If is in then is in and thus is in  Otherwise  let be the shortest suffix of which is in not in  By the dual of Lemma lemmaDeriv2 the word is in  Then is a proper suffix of  since and  and therefore is in  There is a dual version of Proposition propositionScapH concerning the set of proper prefixes of an -thin and -maximal bifix code  The following property generalizes Theorem 6 3 15 in BerstelPerrinReutenauer2009  Let be a recurrent set  Let be a bifix code of finite -degree  The set of its nonempty proper suffixes is a disjoint union of -maximal prefix codes  Let be the set of proper suffixes of  If then is empty  If by Proposition propositionScapH the set is an -maximal prefix code and the set is equal to the set of proper suffixes of the words of the derived code  Arguing by induction  the set is a disjoint union of -maximal prefix codes  Thus is a disjoint union of -maximal prefix codes  The following generalizes Corollary 6 3 16 in BerstelPerrinReutenauer2009 with two restrictions  First  it applies only in the case of finite maximal bifix codes instead of thin bifix codes  in order to be able to use Proposition propMaxPrefixCode  Next  it applies only for recurrent sets such that there exists a positive invariant probability distribution  in order to be able to use Proposition propositionP  Let be a recurrent set such that there exists a positive invariant probability distribution on  Let be a finite bifix code of finite -degree  The average length of with respect to is equal to  Let be a positive invariant probability distribution on  By the dual of Proposition propositionP one has  In view of Theorem theoremDisjointUnion we have where each is a finite -maximal prefix code  By Proposition propMaxPrefixCode we have for  Thus  Let be the Fibonacci set and let  Example exampleDerived  The set is an -maximal bifix code of -degree  With respect to the unique invariant probability distribution of  Example exProba   we have  Now we show that an -thin and -maximal bifix code is determined by its -degree and its kernel  We first prove the following generalization of Proposition 6 4 1 from BerstelPerrinReutenauer2009  Let be a recurrent set  Let be a bifix code of finite -degree and let be the kernel of  Let be a set such that  Then for all For all Denote by the set of factors of the word  Notice that Equation  eqre feqLB  is equivalent to  Thus  to prove  eqre feqprop631a   we have to show that for any one has  The inclusion is clear  Conversely  if is in then and thus  Next  assume that is in  The words in other than are all in  Thus we have again  To show Equation  eqre feqprop631   assume first that  Then by Theorem theoremDegree  Moreover  by Equation  eqre feqprop631a   Thus Equation  eqre feqprop631  holds  Next  suppose that  Then  Since we have by Equation  eqre feqLsub   This proves  eqre feqprop631   Proposition proposition631 will be used to prove the following generalization of Theorem 6 4 2 in BerstelPerrinReutenauer2009  Let be a recurrent set and let be a bifix code of finite -degree  For any one has s X w   min d  s  K X   w      In particular is determined by its -degree and its kernel  Take in Proposition proposition631  Then the formula follows from Equation  eqre feqprop631   Next is determined by and so by through Equation  eqre feqLB   We now state the following generalization of Theorem 6 4 3 in BerstelPerrinReutenauer2009  Let be a recurrent set  A bifix code is the kernel of some bifix code of finite -degree if and only if em  upshap e i    is not an -maximal bifix code  em  upshap e ii     Let be an -thin and -maximal bifix code of -degree and let be its kernel  Condition  i  is satisfied because implies that is equal to its derived code which has -degree  Moreover  for every one has  Since by Equation  eqre feqprop631a   condition  ii  is also satisfied  Conversely  let be a bifix code satisfying conditions  i  and  ii   Let be the function defined by s w   min d  s Y w    It can be verified that the function satisfies the four conditions of Proposition proposition6111  Thus is the parse enumerator of a bifix code  Let  Then and have the same restriction to  Since is bounded on the same holds for  This implies that the code is an -thin and -maximal bifix code by Theorem theoremDegree  Since the code is not an -maximal bifix code  the --parse enumerator is not bounded  Consequently showing that has -degree  Let us prove finally the is the kernel of  Since  by condition  ii   we have  Moreover  for we have  Let  resp   be the indicator of  resp  of  Since and by Equation  eqre feqLB   we conclude that for we have  This implies that if then is in if and only if is in  Thus and is the kernel of   hbt  sse tNadjust wh AHnb 0   110 20   put 0 0    20 20   node 1  0 5    node a  10 10    node b  10 0     node Nmr 0  aa  20 15    node Nmr 0  ba  20 0    node Nmr 0  ab  20 5    rawedge 1 a     rawedge ELside r  1 b     rawedge a aa     rawedge ELside r  a ab     rawedge ELside r  b ba        put 30 0    40 20  0 -5   node 1  0 5    node Nmr 0  a  10 10    node b  10 0     node ba  20 0    node baa  30 5    node Nmr 0  bab  30 -5     node Nmr 0  baab  40 5    rawedge 1 a     rawedge ELside r  1 b     rawedge b ba     rawedge ba baa     rawedge ELside r  ba bab     rawedge baa baab        put 80 0    20 20  0    node 1  0 5    node a  10 10    node Nmr 0  b  10 0     node Nmr 0  aa  20 15    node ab  20 5     node Nmr 0  aba  30 10    rawedge 1 a     rawedge ELside r  1 b     rawedge a aa     rawedge ELside r  a ab     rawedge ab aba       The three -maximal bifix codes of -degree in the Fibonacci set  Let and let be the Fibonacci set  There are three maximal bifix codes of -degree in represented on Figure figureBifix2  Indeed  by Theorem theorem643 the possible kernels are and
Finite maximal bifix codes
 The following generalizes Theorem 6 5 2 of BerstelPerrinReutenauer2009  For any recurrent set and any integer there is a finite number of finite -maximal bifix codes of -degree  The only -maximal bifix code of -degree is  Arguing by induction on assume that there are only finitely many finite -maximal bifix codes of -degree  Each finite -maximal bifix code of -degree is determined by its kernel which is a subset of its derived code  Since is a finite -maximal bifix code of -degree there are only a finite number of kernels and we are done  Let and let be the set of words without factor  There are two finite -maximal bifix codes of -degree namely the code with empty kernel and the code with kernel  The code of -degree with kernel is and thus is infinite  The following result shows that the case of a uniformly recurrent set contrasts with the case since in as soon as there exist infinite maximal bifix codes of degree and thus of all degrees   see e g  for degree and for the general case  Let be a uniformly recurrent set  Any -thin bifix code is finite  Any finite bifix code is contained in a finite -maximal bifix code  Let be an -thin bifix code  Since is -thin  there exists a word  Since is uniformly recurrent there is an integer such that is factor of every word in  Assume for some and let  Set with and nonempty  Then is factor of hence is in a contradiction  We deduce that each in has length at most  Thus is finite  Let be a finite bifix code which is not -maximal  Let  By Theorem theorem643 is the kernel of an -thin and -maximal bifix code of -degree  By the previous argument  is finite  By Theorem 6 6 1 of BerstelPerrinReutenauer2009 any rational bifix code is contained in a maximal rational bifix code  We have seen that the situation is simpler for bifix codes in uniformly recurrent sets  Let be the Fibonacci set  Let  Then is contained in the bifix code which has -degree  see Figure figureBifix2  It is also the kernel of which is a bifix code of -degree  see Table tableBifix  The following is a generalization of Proposition 6 2 10 in BerstelPerrinReutenauer2009  The equality is stated as a comment following Proposition 6 3 9 in in a more general framework  Let be a recurrent set  let be a finite -maximal bifix code and let be a nonempty word in  Let and  If G ne ptyset    quad D ne ptyset    and  quad Gw cap wD  ptyset    then the set is a finite -maximal bifix code with the same -degree as  We use in the proof the following proposition which is an extension of Corollary 3 4 7 of BerstelPerrinReutenauer2009  Let be a recurrent set and let be a -maximal prefix code  Let be a partition of into two prefix codes and let be a finite prefix code such that is -maximal for all  Then the set is an -maximal prefix code  We first prove that is a prefix code  Let and be distinct words in  We show that they are not prefix-comparable  Since is a prefix code  this holds if both words are in  Assume next that  Then with and  If is in then and are not prefix-comparable because they are distinct since and and so and are not prefix-comparable  If set with and  Either and are not prefix-comparable  and then so are and or  In the latter case  and are not prefix-comparable because is a prefix code  and again and are not prefix-comparable  Thus is a prefix code  Let us show that is -maximal  Let  Since is an -maximal prefix code  there is an which is prefix-comparable with  If is in then and thus is prefix-comparable with a word of  Otherwise  we have  Suppose first that is a prefix of  Since is a finite -maximal prefix code  it is not empty and is a prefix of for every  Suppose next that for some word  Since is in and since is an -maximal prefix code  the word is prefix-comparable with some  Thus is prefix-comparable with  The condition  resp   means that is a suffix of  resp  a prefix of  The condition implies that is not in  By Theorem theoremEquivMax the set is an -maximal prefix code  By Proposition propositionOperation1 the set is an -maximal prefix code  Next  we have Y  Y 1 setminus Gw  cup  GwD cap F   We show that is an -maximal prefix code  by applying Proposition propositionCA347  Indeed  consider the partition with and  Then  Clearly is a finite -maximal prefix code  Since is a subset of for all the set is a finite -maximal prefix code for all by Proposition propositionFinitePrefixCodes So the claim follows from by Proposition propositionCA347  This proves that is an -maximal prefix code  Since it is also a suffix code  it follows that is an -maximal bifix code by Theorem theoremEquivMax   hbt  sse tNadjust wh AHnb 0 Nfill y fillgray 1 ELdist 1 5   65 10  0 -5   node 0  0 0     node Nframe n Nadjustdist 0  g  15 0     node r  30 0    rawedge 0 r      node s  65 0    rawedge r s      node w  50 0    rawedge ELside r  r w     rawedge ELside r  w s     rawedge curvedepth -5 ELside r  g r     Construction of  second case   To show that and have the same degree  consider a word which is not an internal factor of nor  Such a word exists since and are finite  Let  resp   be the set of proper prefixes of the words of  resp   We define a bijection between the set of suffixes of which are in and the set of suffixes of which are in  This will imply that by the dual of Proposition propInterpretations  Let be a suffix of and set  If is not a prefix of then is in  Otherwise  set  Since the words in starting with are all prefixes of the word is a proper prefix of  Since is an -maximal suffix code  is suffix-comparable with a word of  If is a proper suffix of then is an internal factor of a contradiction  Thus has a suffix  This suffix is unique because is a suffix code  Since the word is a proper prefix of and thus a proper prefix of  Thus  We set  see Figure figInternal1   varphi p   p	 if
 g p	 if and is the suffix of in  Thus maps into  We show that it is injective  Suppose that for some  Assume that and with  Since and start with the word starts with the words and which are in  This shows that and thus  Assume next that with and  But then is a prefix of with in and in a contradiction   hbt  sse tNadjust wh AHnb 0 Nfill y fillgray 1 ELdist 1 5   80 22  0 -10   node 0  0 0     node g  20 0     node r  35 0     node s  70 0     node q  60 0     node y  80 0     node qleft  20 -10     node qright  60 -10    rawedge ELside r  qleft qright     rawedge 0 g    rawedge g r     rawedge r q     rawedge q s     rawedge curvedepth -6  g q     rawedge curvedepth 8  r y      node 0   0 8     node r   35 8    rawedge 0  r      rawedge dash  1 1 0  s y    rawedge dash  0 2 0 5 0  0 0     rawedge dash  0 2 0 5 0  r r     rawedge dash  0 2 0 5 0  g qleft    rawedge dash  0 2 0 5 0  q qright    Reconstruction of the factorization  To show that is surjective  consider  Assume first that has a prefix in  see Figure figInternal2  By Equation  eqre feqInternalTransformation   one has and for some and a proper prefix of the word in  Thus is a proper prefix of and consequently is a proper prefix of  Since is a suffix of it is a suffix of  Thus  Set  Then is a suffix of  Moreover  Consequently  Finally  if has no prefix in then is a proper prefix of  Moreover  since is a prefix of either is a proper prefix of or is not a prefix of  In both cases  is not a prefix of and therefore  Thus is surjective  The set defined by Equation  eqre feqInternalTransformation   is said to be obtained from by internal transformation  internal transformation   with respect to  Let be the Fibonacci set  The set is an -maximal bifix code of -degree  Then is a bifix code of -degree which is obtained from by internal transformation with respect to  Indeed  here and  The following theorem is due to C  esari  It is Theorem 6 5 4 in BerstelPerrinReutenauer2009  For any finite maximal bifix code over of degree there is a sequence of internal transformations which  starting from the code gives the code  Theorem theoremCesari has been generalized to finite -maximal bifix codes when is the set of paths in a strongly connected graph  see DeFelice1988  It is not true in any recurrent  or even uniformly recurrent set  as shown by the following example  Let be the Fibonacci set  The set is a finite bifix code of -degree  It cannot be obtained by a sequence of internal transformations from the code  Indeed  the only internal transformation which can be realized is with respect to  The result is by Example exampleInternalFibo1  Next  no internal transformation can be realized from this code  See also Figure figureBifix2  A more general form of internal transformation is described in BerstelPerrinReutenauer2009 in Proposition 6 2 8  We do not know whether its adaptation to finite -maximal bifix codes allows one to obtain all finite -maximal bifix codes of -degree starting with the code
Bifix codes in Sturmian sets
 In this section  we study bifix codes in Sturmian sets  This time  the situation is completely specific  First of all  as we have already seen  any -thin bifix code included in a uniformly recurrent set is finite  Theorem theoremCompletion  Next  in a Sturmian set any bifix code of finite -degree on letters has elements  Theorem theoremBifixd 1  Since is a bifix code of degree this generalizes the fact that for all  Additionally  if an infinite word is -stable  that is if for some thin maximal bifix code one has for all suffixes of then the inequality implies that is ultimately periodic  Theorem theoremPeriod
Sturmian sets
 Let be a factorial set on the alphabet  Recall that a word is strict right-special if  It is strict left-special if  A suffix of a  strict  right-special word is  strict  right-special  a prefix of a  strict  left-special word is  strict  left-special  A set of words is called Sturmian  Sturmian set  if it is the set of factors of a strict episturmian word  By Proposition propositionSturmianMinimal a Sturmian set is uniformly recurrent  Moreover  every right-special  left-special  word in is strict  The following statement gives a direct definition of Sturmian sets  A set is Sturmian if and only if it is uniformly recurrent and em  upshap e i    it is closed under reversal  em  upshap e ii    for each there is exactly one right-special word in of length and this right-special word is strict  If for some strict episturmian word  then the conclusions of the proposition hold  Conversely  assume that has the required properties  For each the reversal of the strict right-special word of length is a strict left-special word  Since all these left-special words are prefixes one of the other  there is an infinite word that such that all its prefixes are these strict left-special words  Clearly   To show that is strict episturmian  we verify that is closed under reversal  Let  Then  Since is uniformly recurrent  there is an integer such that is a factor of the right-special word of length  Consequently the reversal of is a factor of the left-special word of length and therefore is in  To prove that let  Since is uniformly recurrent  there is an integer such that is a factor of the left-special word of length  Since is a prefix of this shows that  The following statement is a direct consequence of the previous proof  Let be a Sturmian set of words  There is a unique strict standard episturmian infinite word such that  As a consequence of Proposition leftInfinite for every left-special word of a Sturmian set exactly one of the words for is left-special in  Symmetrically  for every right-special word in exactly one of the words for is right-special in  More generally  for every there is exactly one word of length such that is a right-special word in  Any word in a Sturmian set is a prefix of some right-special word in  Let indeed  Since is uniformly recurrent  there is an integer such that is a factor of any word in of length  Let be the right-special word of length  Then is a factor of thus for some words  Since is right-special  its suffix is also right-special  Thus is a prefix of a right-special word  The following example shows that for a Sturmian set there exists bifix codes which are not -thin  we have seen such an example for a uniformly recurrent but not Sturmian set in Example exampleDenseBifixCode  Let be a Sturmian set  Consider the following sequence of words of  Set for some  Suppose inductively that have been defined in such a way that is bifix and not -maximal bifix  Define as follows  By Theorem theoremEquivMax is not right -complete  thus there is a word in which is incomparable for the prefix order with the words of  By Proposition propositionPrefixSpecial the word is a prefix of a right special word in  Symmetrically  since is not an -maximal bifix code  there is a word which is incomparable with the words of for the suffix order  Since is recurrent  there is a word such that  Then we choose  The set is a bifix code since is incomparable with the words of for the prefix and for the suffix order  It is not an -maximal prefix code since for all letters is incomparable for the prefix order with the words of   indeed  its prefix is incomparable for the prefix order with all words in and is incomparable with  Since it is finite  it is not an -maximal bifix code by Theorem theoremEquivMax  The infinite set is a bifix code included in and it is not -thin by Theorem theoremCompletion  Let be a Sturmian set and let be a prefix code  Then contains at most one left-special word  If is a finite -maximal prefix code  it contains exactly one left-special word  Assume on the contrary that are two left-special words  We may assume that  Let be the prefix of of length  Then is left-special and thus are two left-special words of the same length  This implies that  Thus is a prefix of  Since is prefix  this implies  Assume now that is a finite -maximal prefix code  Let be the maximal length of the words in  Let be the left-special word of length  Since is right -dense  there is a prefix of which is in  Thus is a left-special element of  It is unique by the previous statement  A dual of Proposition propPrefixSpecial holds for suffix codes and right-special words 
Cardinality
 The following result shows that Theorem theoremCompletion can be made much more precise for Sturmian sets  Let be a Sturmian set on an alphabet with letters  For any finite -maximal bifix code one has  The following corollary is strong generalization of a result related to Sturmian words  Let be a Sturmian word over and let be a finite maximal bifix code of degree  Then  Indeed  since is a finite maximal bifix code of degree this corollary  re proves that any Sturmian word has factors of length and it extends this to arbitrary finite maximal bifix code of degree  A similar extension holds for strict episturmian words  medskip Set  In view of Theorem proposition1 one has  Consequently  by the formula of Theorem theoremBifixd 1  The proof of Theorem theoremBifixd 1 uses two lemmas  Let be a Sturmian set  Let be a finite bifix code of finite -degree and let be the set of proper prefixes of  There exists a right-special word such that  The suffixes of which are in are the right-special words contained in  Let be larger than the length of the words of  By definition  there is a right-special word of length  Then is not a factor of a word of  By Theorem theoremDegree it implies that  By the dual of Proposition propInterpretations the word has suffixes which are in  They are all right-special words  Furthermore  any right-special word contained in is a suffix of  Indeed  the suffix of of the same length than is the unique right-special word of this length  The next lemma is a well-known property of trees translated into the language of prefix codes  Let be a prefix code or the set and let be the set of proper prefixes of  For let  Let be an alphabet with letters  Let be a finite prefix code or the set and let be the set of proper prefixes of the words of  Assume that for all or  Let  Then   Let us prove the property by induction on the maximal length of the words in  The property is true for since in this case and  Assume  If then all words of begin with the same letter  We have then is a prefix code or the set and  Hence  by induction hypothesis  Otherwise   Set  We have  By induction hypothesis   Therefore   Let be the set of proper prefixes of  An element of satisfies if and only it is right-special  Thus the conclusion follows directly by Lemmas lemmadSpecial and lemmaTree   hbt   hline code 	 kernel 	 derived code
  hline aab aba baa bab 	 ptyset 	aa ab ba
 aa aba baab bab 	aa
 aaba ab baa baba 	ab
 aab abaa abab ba 	ba
 aa ab baaba baba 	aa ab
 aa abaab abab ba 	aa ba
 aabaa aababaa ab ba 	ab ba
  hline a baabaab baabab babaab 	a 	a baab bab
 a baab babaabaabab babaabab 	a baab
 a baabaab baababaab bab 	a bab
  hline aaba abaa ababa b 	b 	aa aba b
 aa abaaba ababa b 	aa b
 aabaa aababa aba b 	aba b
  hline The -maximal bifix codes of -degree in the Fibonacci set  Let be the Fibonacci set  We have seen in Example exampleFiboDegree2 that there are -maximal bifix codes of -degree 2  It appears that there are -maximal bifix codes of degree listed in Table tableBifix  These codes are determined by their derived -maximal bifix codes of -degree 2  and by the choice of the kernel  The construction of the code can be done by Theorem theoremkerneldegree  By Theorem theoremBifixd 1 all these codes have elements   hbt  sse tNadjust wh AHnb 0   110 20  0 -10   node fillgray 0  1  0 5    node Nmr 0  a  10 10    node b  10 0     node fillgray 0  ba  20 0    node baa  30 5    node Nmr 0  baab  40 5     node bab  30 -5     node baba  40 -5     node babaa  50 -5     node babaab  60 -5     node fillgray 0  babaaba  70 -5     node babaabaa  80 0     node babaabaab  90 0     node babaabaaba  100 0     node Nmr 0  babaabaabab  110 0     node Nmr 0  babaabab  80 -10    rawedge 1 a     rawedge ELside r  1 b     rawedge b ba     rawedge ba baa     rawedge ELside r  ba bab     rawedge baa baab     rawedge bab baba     rawedge baba babaa     rawedge babaa babaab     rawedge babaab babaaba     rawedge babaaba babaabaa     rawedge ELside r  babaaba babaabab     rawedge babaabaa babaabaab     rawedge babaabaab babaabaaba     rawedge babaabaaba babaabaabab     The -maximal bifix code of -degree 3 with kernel  We may illustrate the proof of Theorem theoremBifixd 1 on the code  see Table tableBifix  According to Lemma lemmadSpecial the right-special word  which is the reversal of the prefix of the Fibonacci word  has exactly three suffixes which are proper prefixes of words of namely and  these are the   fork nodes    that is the nodes with two childred  indicated in black on Figure figureExd 1  This implies  by Lemma lemmaTree that has four elements  The following example shows that Theorem theoremBifixd 1 is not true for the set of factors of an episturmian word which is not strict  Set  Let be the Fibonacci word and let be the infinite word of Example exampleNonStrict  It is an episturmian word which is not strict  Set  Let be the morphism from onto the group defined by and  Let be the group code such that  Since has elements  the degree of is  see Proposition propositionGroupAutomaton below   The bifix code has elements obtained by inserting in two possible ways in the words of the bifix code  The latter has degree 4 by Theorem theoremBifixd 1  The bifix code is given in Figure figureExNonStrict  The numbering of the nodes is for later use  in Example exNonStrictGroup   hbt   108 55  0 -10  sse tNadjust wh AHnb 0   node 1  0 20      node a  9 30     node b  9 20     node c  9 10      node ac  18 30     node bc  18 20     node ca  18 10     node cb  18 -1      node aca  27 40     node acb  27 30     node bca  27 20      node cac  27 10     node cbc  27 -1      node Nmr 0  acac  36 40     node acbc  36 30     node bcac  36 20      node Nmr 0  caca  36 14     node cacb  36 7      node cbca  36 -1      node acbca  45 30     node bcaca  45 22     node bcacb  45 15      node cacbc  45 7     node cbcac  45 -1      node acbcac  54 30     node bcacac  54 22     node bcacbc  54 15      node cacbca  54 7     node cbcaca  54 -1     node cbcacb  54 -10      node acbcaca  63 40     node acbcacb  63 30      node bcacacb  63 22     node bcacbca  63 15      node cacbcac  63 7     node cbcacac  63 -1      node cbcacbc  63 -10      node acbcacac  72 40     node Nmr 0  acbcacbc  72 30      node Nmr 0  bcacacbc  72 22     node Nmr 0  bcacbcac  72 15      node cacbcaca  72 10      node Nmr 0  cacbcacb  72 4      node Nmr 0  cbcacacb  72 -1     node Nmr 0  cbcacbca  72 -10      node acbcacacb  81 40      node cacbcacac  81 10      node acbcacacbc  90 40      node cacbcacacb  90 10      node acbcacacbca  99 40      node cacbcacacbc  99 10      node Nmr 0  acbcacacbcac  108 40      node Nmr 0  cacbcacacbca  108 10     rawedge 1 a     rawedge 1 b     rawedge 1 c     rawedge a ac     rawedge b bc     rawedge c ca     rawedge c cb     rawedge ac aca     rawedge ac acb     rawedge bc bca     rawedge ca cac     rawedge cb cbc     rawedge aca acac     rawedge acb acbc     rawedge bca bcac     rawedge cac caca     rawedge cac cacb     rawedge cbc cbca     rawedge acbc acbca     rawedge bcac bcaca     rawedge bcac bcacb     rawedge cacb cacbc     rawedge cbca cbcac     rawedge acbca acbcac     rawedge bcaca bcacac     rawedge bcacb bcacbc     rawedge acbcac acbcaca     rawedge acbcac acbcacb     rawedge bcacac bcacacb     rawedge cacbc cacbca     rawedge cbcac cbcaca     rawedge ELside r  cbcac cbcacb     rawedge acbcaca acbcacac     rawedge acbcacb acbcacbc     rawedge bcacacb bcacacbc     rawedge bcacbc bcacbca     rawedge bcacbca bcacbcac     rawedge cacbca cacbcac     rawedge cbcaca cbcacac     rawedge cbcacb cbcacbc     rawedge cacbcac cacbcaca     rawedge cacbcac cacbcacb     rawedge cbcacac cbcacacb     rawedge cbcacbc cbcacbca     rawedge acbcacac acbcacacb     rawedge cacbcaca cacbcacac     rawedge acbcacacb acbcacacbc     rawedge cacbcacac cacbcacacb     rawedge acbcacacbc acbcacacbca     rawedge cacbcacacb cacbcacacbc     rawedge acbcacacbca acbcacacbcac     rawedge cacbcacacbc cacbcacacbca     An -maximal bifix code with elements  The numbers in the vertices are for later use  By Theorem proposition1 is an -maximal bifix code  Its -degree is  Indeed  the word has parses  Thus Theorem theoremBifixd 1 is not true in this case  As a consequence of Theorem theoremBifixd 1 an internal transformation does not change the cardinality of a finite -maximal bifix code for a Sturmian set  Indeed  by Proposition propositionInternalTransformation an internal transformation preserves the -degree  Actually  if is obtained from by internal transformation with respect to we have and  Card Y   Card X  1  Card GwD cap F - Card G - Card D   The fact that internal transformations preserve the cardinality can be proved directly by the following statement  This statement applies to the internal transformation  eqre feqInternal  because is a bifix code  which implies property  i  and  resp   which implies property  ii   resp   iii    Let be Sturmian set  let be a nonempty word and let be finite sets such that em  upshap e i    any word has at most one factorization with and em  upshap e ii    is a prefix code contained in and is right -dense  em  upshap e iii    is a suffix code contained in and is left -dense  Then  Let be a set made of copies of and  The tensor product notation is used to emphasize that the copies of and are disjoint  Let be the undirected graph having as set of vertices and as edges the pairs such that  this graph is close to  but slightly different from the incidence graph for as it will be defined in Section sectionPreliminaries  We have and  by condition  i    We show that the graph is a tree  This implies our conclusion since  in a tree  one has  Let us prove that the graph is a tree by induction on the sum of the lengths of the words of assuming that the pair satisfies conditions  ii  and  iii   Assume first that  Since one has  Consequently  for any  Thus is a tree  Next  assume that  Let be of maximal length  Set with  Suppose first that  Let  Since is -dense  the word is not right-special  Thus for each we have if and only if  This shows that the graph is isomorphic to the graph corresponding to the pair  The set satisfies condition  ii   By induction is a tree  Consequently is a tree  Suppose next that has more than one element  Then is right-special and  Let  Then satisfies condition  ii   Let be the graph corresponding to the pair  By induction hypothesis  the graph is tree  Since is right-special  Let be a right-special word such that is longer than any word of  Since is -dense  and since has a suffix in  Thus is right-special  We have for all  For any other element such that since is not right-special  there is exactly one such that  There is a path between and every since for some and for all  see Figure figureGraphs  Thus the graph is connected and acyclic  and therefore is a tree   hbt  sse tAHnb 0   80 30   put 0 0    30 40   node g   0 30      node g  0 20      node g    0 10      node Nframe n  G  0 0      node d   30 20      node Nframe n  D   30 0     rawedge g d     rawedge d  g     rawedge d  g         put 50 0    30 40   node g   0 30      node g  0 20      node g    0 10      node Nframe n  G  0 0      node d a  30 25     node d b  30 15     rawedge g d a    rawedge g d b    rawedge d a g     rawedge d b g       node Nframe n  D  30 0       The graphs and  The following example shows that condition  i  is necessary  Let be the Fibonacci set  Let and  Then conditions  ii  and  iii  are satisfied but not condition  i   We have and thus the conclusion of Proposition propositionChristophe is false  Let be the Fibonacci set and let be the set of words of of length  The internal transformation from relative to the word gives  We have  The codes and the graph of the proof of Proposition propositionChristophe are represented on Figure exInternal   hbt  sse tNadjust wh AHnb 0   120 30   put 0 0    40 30   node 1  0 12    ef  h9   node a   h 20    node b   h 4    ef  h18   node aa   h 24    node ab   h 16    node ba   h 4    ef  h27   node aab   h 24    node aba   h 16    node baa   h 8     node bab   h 0    ef  h36   node Nmr 0  aaba   h 24    node Nmr 0  abaa   h 20    node Nmr 0  abab   h 12     node Nmr 0  baab   h 8    node Nmr 0  baba   h 0    rawedge 1 a     rawedge ELside r  1 b     rawedge a aa     rawedge ELside r  a ab     rawedge b ba     rawedge aa aab     rawedge ab aba     rawedge ba baa     rawedge ELside r  ba bab     rawedge aab aaba     rawedge aba abaa     rawedge ELside r  aba abab     rawedge ELside r  baa baab     rawedge bab baba        put 45 0    40 30   node 1  0 12    ef  h9   node a   h 20    node b   h 4    ef  h18   node aa   h 24    node ab   h 16    node ba   h 4    ef  h27   node aab   h 24    node Nmr 0  aba   h 16    node baa   h 8     node bab   h 0    ef  h36   node aaba   h 24     node Nmr 0  baab   h 8    node baba   h 0    ef  h44   node Nmr 0  aabaa   h 28    node Nmr 0  aabab   h 20     node Nmr 0  babaa   h 0    rawedge 1 a     rawedge ELside r  1 b     rawedge a aa     rawedge ELside r  a ab     rawedge b ba     rawedge aa aab     rawedge ab aba     rawedge ba baa     rawedge ELside r  ba bab     rawedge aab aaba     rawedge baa baab     rawedge bab baba     rawedge aaba aabaa     rawedge ELside r  aaba aabab     rawedge baba babaa        put 100 5    20 20  sset AHnb 0   node 1a  0 15     node 1b  0 0      node a1  20 15     node b1  20 0     rawedge 1a a1    rawedge 1a b1    rawedge 1b a1      The codes and the graph
Periodicity
 Let with be an infinite word  It is periodic  periodic word   word periodic  if there is an integer such that for all  It is ultimately periodic  ultimately periodic word   word ultimately periodic  if the equalities hold for all large enough  Thus  is ultimately periodic if there is a word and a periodic infinite word such that  The following result  due to Coven and Hedlund  is well-known  see Lothaire2002 Theorem 1 3 13   Let be an infinite word on an alphabet with letters  If there exists an integer such that has at most factors of length then is ultimately periodic  We will prove a generalization of this result  Let be an infinite word and let be a thin maximal bifix code  Let be a prefix of and set  Since one has  The word is called - stable  stable word   X-stable  -stable word   word stable  if for all suffixes of  Let be a prefix of such that is minimal  Then the infinite word is -stable  For example  if and then an -stable suffix of is  Let be a thin maximal bifix code and let be an -stable infinite word  If then is ultimately periodic  Let be an infinite word  If there exists a finite maximal bifix code of degree such that then is ultimately periodic  Since any long enough word has parses  and is -stable  Since the conclusion follows by Theorem theoremPeriod  Corollary corollaryPeriod implies Theorem theoremCovenHedlund in the case since is a maximal bifix code of degree  Let us consider again the finite maximal bifix code of degree defined by  see Example exFiboDegre2  Assume that where and  Since is a factor of there exist a word and an infinite word such that  Next  the first letter of is  otherwise   and the second letter of is  otherwise   This argument shows that whenever is a prefix of then is also a prefix of i e   with  The set is a maximal bifix code of degree 2  An argument similar to the previous one shows that any infinite word such that belongs to the set  Thus it is ultimately periodic  Let be an infinite word and let be a thin maximal bifix code  Let be an -stable suffix of and let  If then is ultimately periodic  By Theorem theoremPeriod the word is ultimately periodic  and so is  The following example shows that Corollary corollaryPeriod2 may become false if we replace by in the statement  Let be the maximal bifix code of degree on the alphabet with kernel  Let where is an infinite word without any occurrence of  Then has no factor in  Indeed  a word of of length at most is in the kernel of and thus is not a factor of  Thus has parses with respect to namely and  Thus we have  On the other hand and thus although need not be ultimately periodic  This shows that we cannot replace by in the statement of Corollary corollaryPeriod2  The proof uses the Critical Factorization Theorem  see Lothaire1983 CrochemorePerrin1991  that we recall below  For a pair of words consider the set of nonempty words such that A  p cap A  r ne ptyset  quad sA   cap rA   ne ptyset    This is the set of nonempty words which are prefix-comparable with and suffix-comparable with  This set is nonempty since it contains  The repetition  repetition  is the minimal length of such a nonempty word  Let be a word with  An integer is a period  period of a word  of if for implies  Recall that a factorization  factorization of a word  of a word is a pair of words such that   Critical Factorization Theorem  For any word the maximal value of for all factorizations of is the least period of  We will also use the following lemma  Let be an infinite word and be an integer such that the least period of an infinite number of prefixes of is at most  Then is periodic  Since the least period of an infinite number of prefixes of is at most an infinity of them have the same least period  Let be such that an infinite number of prefixes of have least period  Set with  For each there is a prefix of of length larger than with least period  Thus  This shows that is periodic  Let and  Set and  Since the set is finite  Since is -stable  there are an infinite number of factors and therefore also of prefixes of which have parses with respect to  Indeed  for any factorization we have and thus has a factor which has parses  so it has a prefix with parses  and finally is a prefix of with parses  Let be the maximal length of the words in  Let be a prefix of of length larger than which has parses and set  Let be a nonempty prefix of and set  Let be a prefix of of length larger than which has parses  Let be a factorization of  We show that  Since has parses with respect to there are suffixes of which are in  We may assume that  Similarly  there are prefixes of which are in  We may assume that  Since has parses  for each with there is exactly one with such that  Indeed  there is a prefix of such that  Since must be one of the the conclusion follows  We may renumber the in such a way that for  Set  Since we have  Let be the word of which is a suffix of  Similarly  let be the word of which is a prefix of  see Figure figureInterpretations   hbt  sse tNadjust wh AHnb 0   80 20  0 -5   node uh  0 10    node ph  20 10    node sh  40 10    node zh  60 10    node endh  80 10     node u  0 0    node p  20 0    node x1  25 0    node xi  32 0    node s  40 0    node fin  48 0     node x2  55 0     node z  60 0    node end  80 0    rawedge curvedepth 3  xi fin     rawedge uh ph     rawedge ph sh     rawedge sh zh     rawedge zh endh     rawedge u p     rawedge p x1    rawedge x1 xi    rawedge xi s    rawedge s fin    rawedge fin x2    rawedge x2 z    rawedge z end     rawedge curvedepth -5 ELside r  x1 s     rawedge curvedepth -5 ELside r  s x2     The words  Since two of the words are equal  If then  If for an index with then is a suffix of  since it is a suffix of  and a prefix of  by definition of  Furthermore  since is the maximal length of the words of  Thus  The case where for an index with is similar  Assume finally that for some indices such that  We may assume that  Thus  As a consequence  is both a suffix of  since it is a suffix of  and a prefix of  since it is a prefix of  Thus again   By the Critical Factorization Theorem  this implies that the least period of is at most equal to  Thus an infinite number of prefixes of have least period at most  By Lemma lemmaPeriodInfinite it implies that is periodic 
Bases of subgroups
 In this section  we push further the study of bifix codes in Sturmian sets  The main result of Section subsectionSturmianBasis is Theorem theoremGroups  It states that a -maximal bifix code of -degree is a basis of a subgroup of index of the free group on  The proof uses two sets of preliminary results  The first part concerns bases of subgroups composed of words over already considered in Reutenauer1979  The second one uses the first return words  which were introduced independently in Durand1998 HoltonZamboni1999 and which we use in the framework of JustinVuillon2000 and Vuillon2001 up to a left-right symmetry  see also AraujoBruyere2005  We denote by the free group generated by  The rank  rank free group  of is  Note that all sets generating a free group of rank have at least elements  A basis is a minimal generating set  All bases have exactly elements  see e g  LyndonSchupp2001  Let be a subgroup of rank and of index of a free group of rank  Then Formula  eqre fequationSchreier  is called Schreier s Formula  Schreier s Formula   The free monoid is viewed as embedded in  An element of the free group is represented by its unique reduced word on the alphabet  The elements of the free monoid are themselves reduced words since they do not contain any letter in  Thus is a submonoid of  The subgroup of generated by a subset of is denoted  In any group the right cosets  right cosets of a subgroup   subgroup right cosets  of a subgroup are the sets of the form for  Two right cosets of the same subgroup are disjoint or equal  The index  index of a subgroup   subgroup index  of a subgroup is the number of its distinct right cosets  If is a subgroup of the subgroup then the index of in is the product of the index of in and of the index of in  If are two subgroups of index of a group then implies  Assume now that is a group of permutations over a set  For any in the set of elements of that fixes is a subgroup of  The group is transitive  transitive permutation group   permutation group transitive  if  for all there is an element such that  In this case  the subgroup of permutations fixing a given element of has index  Indeed  for each let be an element of such that  If is such that then and consequently whence  Thus each is in one of the right cosets for  Since these right cosets are pairwise disjoint  the index of is
Group automata
 A simple automaton is said to be reversible  automaton reversible   reversible automaton  if for any the partial map is injective  This condition allows to construct the reversal of the automaton  reversal of an automaton  as follows  whenever in then in the reversal automaton  The state is the initial and the unique terminal state of this automaton  Any reversible automaton is minimal Reutenauer1979  The set recognized by a reversible automaton is a left and right unitary submonoid  Thus it is generated by a bifix code  An automaton is a group automaton  group automaton   automaton group  if for any the map is a permutation of  When is finite  a group automaton is a reversible automaton which is complete  The following result is from Reutenauer1979  see also Exercise 6 1 2 in BerstelPerrinReutenauer2009  Let be a bifix code  The following conditions are equiva -lent  em  upshap e i      em  upshap e ii    the minimal automaton of is reversible  Let be a deterministic automaton  A generalized path  generalized path   path generalized  is a sequence with and such that for one has if and if  The label of the generalized path is the element of the free group  Note that if the set of labels of generalized paths from to in is a subgroup of  It is called the subgroup described  subgroup described  by  A path in an automaton is a particular case of a generalized path  In the case where has a unique terminal state which is equal to the initial state  the submonoid of recognized by is contained in the subgroup of described by  Let be the automaton defined by and  The submonoid recognized by is  The subgroup described by is the cyclic group generated by  Let be a simple automaton and let be the prefix code generating the submonoid recognized by  The subgroup described by is generated by  If moreover is reversible  then  Set  Let be the subgroup described by  Let us show that  First  implies  To prove the converse inclusion  let be a generalized path with and  Let be the label of the path  Let be the number of indices such that  We show by induction on that  This holds clearly if  Assume that it is true for  Let be the least index such that  Set in such a way that  Set also and  Thus and is the label of a generalized path from to  Since is trim there exist words such that and  Since  see Figure figureStallings   we have  By induction hypothesis  since is the label of a generalized path from to we have  Then is in and thus  Assume now that is reversible  Then is minimal and  by Proposition lemmaExercise612 one has   hbt  sse tNadjust wh   40 20   node 1  0 10     node p  40 18     node q  40 2     rawedge ELside r  1 p     rawedge q p     rawedge 1 q     rawedge ELside r curvedepth -6  p 1     rawedge dash  0 2 0 5 0 curvedepth 6  q 1     Paths in the automaton  The generalized path is dashed  For any subgroup of the submonoid is right and left unitary  Thus is generated by a bifix code  A subgroup of is positively generated  subgroup positively generated  if there is a set which generates  In this case  the set generates the subgroup  Let be the bifix code which generates the submonoid  Then generates the subgroup  This shows that  for a positively generated subgroup there is a bifix code which generates  For any positively generated subgroup of there is a unique reversible automaton such that is the subgroup described by  Let be the bifix code generating the submonoid so that  Since is positively generated  the subgroup generated by is equal to that is  Thus  In view of Proposition lemmaExercise612 the minimal automaton of is reversible  Thus the submonoid recognized by is and by Proposition propGeneratedGroup is the subgroup described by  If is another reversible automaton such that is the subgroup described by then by Proposition lemmaExercise612 recognizes the set  Since is minimal and since minimal automata are unique  the uniqueness follows  The reversible automaton such that is the subgroup described by is called the Stallings automaton  Stallings automaton  of the subgroup  It can also be defined for a subgroup which is not positively generated  see BartholdiSilva2011 or KapovichMyasnikov2002  The following conditions are equivalent for a submonoid of  em   i   is recognized by a group automaton with states  em   ii   where is a subgroup of index of a group and is a surjective morphism from onto  em   iii   where is a subgroup of index of  If one of these conditions holds  the minimal generating set of is a maximal bifix code of degree   i  implies  ii   Let be a group automaton with states and let be the set recognized by  Since a composition of permutations is a permutation  the monoid is a permutation group  Since is trim  there is a path from every state to any state in  Consequently  is transitive  Let be the subgroup of formed of the permutations fixing  As we have seen earlier  has index  Then   ii  implies  iii   Let be the morphism from onto extending  Then is a subgroup of index of and   iii  implies  i   Let be the set of right cosets of with denoting the right coset  The representation of by permutations on defines a group automaton with states and is recognized by  Finally  let be the minimal generating set of a submonoid satisfying one of these conditions  It is clearly a bifix code  Let be the set of proper prefixes of  The number of suffixes of a word which are in is at most equal to  Indeed  let be a group automaton recognizing  If are distinct suffixes of a word which are in then  Indeed  otherwise  since and are suffix-comparable  we may assume that  Let  Then and thus since is reversible  Thus  Let be a word with the maximal number of suffixes in  Then cannot be an internal factor of  Moreover the number of suffixes of in is equal to  Indeed  since is a group code  for any there is a state such that  Since is not an internal factor of there is a factorization such that and and such that is a parse of  Thus has degree  A bifix code such that satisfies one of the equivalent conditions of the proposition propositionGroupAutomaton is called a group code  group code   code group   The following proposition shows in particular that a subgroup of finite index is positively generated  Let be a subgroup of finite index of  The minimal automaton of is a group automaton which describes the subgroup  Let be the group code such that recognizes  The subgroup generated by is  By Proposition propositionGroupAutomaton the monoid is recognized by a group automaton which is the minimal automaton of  The morphism from onto the group of Proposition propositionGroupAutomaton extends to a morphism from onto  The subgroup is composed of the permutations that fix and the subgroup is formed of the elements such that the permutation fixes  There is a generalized path in from to labeled if and only if  Thus fixes if and only there is a generalized path from to labeled that is if  Thus the subgroup described by is  By Proposition propGeneratedGroup the subgroup is generated by  The set is a group code by Proposition propositionGroupAutomaton  ii   Thus it is a maximal bifix code of degree  The intersection of the subgroup generated by with is the submonoid generated by  Proposition propGroupCode  It is composed of the words with length a multiple of
Main result
 We will prove the following result  Let be a Sturmian set and let be an integer  A bifix code is a basis of a subgroup of index of if and only if it is a finite -maximal bifix code of -degree  Note that Theorem theoremBifixd 1 is contained in Theorem theoremGroups  we will use Theorem theoremBifixd 1 in the proof of Theorem theoremGroups  Indeed  let be an -maximal bifix code of -degree  By Theorem theoremCompletion is finite  By Theorem theoremGroups the subgroup has rank and index in the free group  By Schreier s Formula  eqre fequationSchreier   one get  Before proving Theorem theoremGroups we list some corollaries  Let be a Sturmian set  For any the set of words in of length is a basis of the subgroup of generated by  The set is a group code  see Example exampleAd   and therefore is a maximal bifix code  The set is a finite bifix code  By Theorem proposition1 it is an -maximal bifix code and has -degree  The corollary follows from Theorem theoremGroups  Indeed since both are subgroups of of index  The following is also a complement to Theorem proposition1  It shows in particular that for any Sturmian set any subgroup of of finite index has a basis contained in  Note that this This provides contains the fact that every subgroup of finite index has a positive basis  see also Proposition propGroupCode  Let be a Sturmian set  The map which associates to the subgroup of generated by is a bijection between -maximal bifix codes of -degree and subgroups of of index  Such a bifix code is a basis of  The reciprocal bijection associates  to a subgroup of the set where is the group code which is the minimal generating set of the submonoid of  Let first be a finite -maximal bifix code of -degree  Then is a subgroup of index by Theorem theoremGroups  Conversely  let be a subgroup of index of and let be the group code such that  By Theorem proposition1 the set is an -maximal bifix code of -degree  By Theorem theoremCompletion is finite  By Theorem theoremGroups the subgroup has index  Since is a subgroup of is a multiple of  Thus and  Finally  let be an -maximal bifix code of -degree  Then is a subgroup of index of  Let be the group code such that and let  Then and thus since is an -maximal bifix code  This shows that the two maps are mutually inverse  A set of words of is balanced  balanced set of words  if for all implies  It is a classical property that the set of factors of a Sturmian word is balanced  Theorem 2 1 5 in Lothaire2002  Thus any Sturmian set on two letters is balanced  Following Richomme and S  e  ebold RichommeSeebold2010 we say that a subset of is factorially balanced  factorially balanced set of words   balanced set of words factorially  if the set of factors of words of is balanced  They show that a finite set is contained in some Sturmian set if and only if it is factorially balanced  Thus  we have the following consequence of Theorem theoremGroups  Let be a bifix code  The following conditions are equivalent  em  upshap e i    There exists a Sturmian set such that and is a finite -maximal bifix code  em  upshap e ii    is a factorially balanced basis of a subgroup of finite index of  As a further consequence of Theorem theoremGroups we have the following result  Let be a Sturmian set on an alphabet with letters  The number of finite -maximal bifix codes of -degree satisfies and N  d k  d d    k-1 - sum  i 1   d-1   d-i     k-1 N  i k   The formula results directly from the formula  due to Hall Hall1949 for the number of subgroups of index in a free group of rank  The values for are given by the recurrence N  d 2  d   d - sum  i 1   d-1  d-i  N  i 2   The first values are d	1 	 2	 3	 4	 5	 6	7 	 8	 9	10
  hline N  d 2  	1 	 3	1 3	7 1	46 1	344 7	2909 3	27334 3	 282932 5	 31998903 The values for are consistent with Examples exampleFiboDegree2 and exampleDegree3  The formula is known to enumerate also the indecomposable permutations on elements  see DressFranz1985 OssonaRosenstiehl2004 and Cori2009
Incidence graph
 Let be a set  let be the set of its proper prefixes and be the set of its proper suffixes  Set and  The incidence graph  incidence graph   graph incidence  of is the undirected graph defined as follows  The set of vertices is  Similarly to the proof of Proposition propositionChristophe the tensor product notation is used to emphasize that is made of two disjoint copies of and  The edges of are the pairs for and such that  Let be a connected component of that is a maximal set of vertices connected by paths  The trace  trace of a component  of on is the set of such that  Similarly  the trace of on is the set of such that   hbt  sse tNadjust wh AHnb 0   110 20  0 -10   node 1  0 5    node Nmr 0  a  10 10    node fillcolor red  b  10 0     node fillcolor blue  ba  20 0    node fillcolor red  baa  30 5    node Nmr 0  baab  40 5     node fillcolor blue  bab  30 -5     node fillcolor red  baba  40 -5     node fillcolor blue  babaa  50 -5     node fillcolor blue  babaab  60 -5     node fillcolor red  babaaba  70 -5     node fillcolor blue  babaabaa  80 0     node fillcolor blue  babaabaab  90 0     node fillcolor red  babaabaaba  100 0     node Nmr 0  babaabaabab  110 0     node Nmr 0  babaabab  80 -10    rawedge 1 a     rawedge ELside r  1 b     rawedge b ba     rawedge ba baa     rawedge ELside r  ba bab     rawedge baa baab     rawedge bab baba     rawedge baba babaa     rawedge babaa babaab     rawedge babaab babaaba     rawedge babaaba babaabaa     rawedge ELside r  babaaba babaabab     rawedge babaabaa babaabaab     rawedge babaabaab babaabaaba     rawedge babaabaaba babaabaabab     The -maximal bifix code of -degree 3 with kernel  Consider the -maximal bifix code of -degree in the Fibonacci set given in Figure copie de figureExd 1  It is a colored copy of Figure figureExd 1  The incidence graph of is given in Figure figureGrapheD3  It has two connected components colored red and blue  The vertices on the left side are the  written simply for convenience   The vertices on the right side are the with the same convention  The color on the node in Figure copie de figureExd 1 corresponds to the color of the corresponding prefix in Figure figureGrapheD3   hbt  sse tNw 0 Nh 0 Nframe n AHnb 0 ExtNL y NLangle 0 NLdist 1   40 66  0 0   node NLangle 180  g0  0 0   color red       node d0  40 0   color red       node NLangle 180  g1  0 6   color blue       node d1  40 6   color blue       node NLangle 180  g2  0 12   color blue       node d2  40 12   color blue       node NLangle 180  g3  0 18   color red       node d3  40 18   color red       node NLangle 180  g4  0 24   color blue       node d4  40 24   color red       node NLangle 180  g5  0 30   color blue       node d5  40 30   color blue       node NLangle 180  g6  0 36   color red       node d6  40 36   color blue       node NLangle 180  g7  0 42   color blue       node d7  40 42   color red       node NLangle 180  g8  0 48   color red       node d8  40 48   color blue       node NLangle 180  g9  0 54   color blue       node d9  40 54   color blue       node NLangle 180  g10  0 60   color red       node d10  40 60   color red      rawedge linecolor red  g10 d10    rawedge linecolor red  g10 d7    rawedge linecolor red  g10 d3    rawedge linecolor blue  g9 d9    rawedge linecolor blue  g9 d6    rawedge linecolor blue  g9 d1    rawedge linecolor red  g8 d0    rawedge linecolor blue  g7 d8    rawedge linecolor blue  g7 d5    rawedge linecolor red  g6 d7    rawedge linecolor red  g6 d4    rawedge linecolor blue  g5 d6    rawedge linecolor blue  g5 d2    rawedge linecolor blue  g4 d5    rawedge linecolor blue  g4 d1    rawedge linecolor red  g3 d4    rawedge linecolor red  g3 d0    rawedge linecolor blue  g2 d2    rawedge linecolor blue  g1 d1    rawedge linecolor red  g0 d0    The incidence graph of  The following lemma uses an argument similar to Lemma lemmaTree  Let be words such that are not prefix-comparable for  Let be the longest common prefix of for  If two of the are prefix-comparable  then two of the are equal  Let let be the set of proper prefixes of and let  The set is the set of words of which have no proper prefix in  The set is a prefix code  If two distinct words in are prefix-comparable  then  Let be the number of distinct  Since are not prefix-comparable for for each there are at least two distinct letters such that  This implies  Indeed  the set can be seen as the set of leaves in a tree  and each is a fork node  i  e  a node with at least two children  in this tree  It is well-known that the number of fork nodes is strictly less than the number of leaves  If two of the are prefix-comparable  the inequality implies and consequently two of the are equal  Let be a Sturmian set and let be a bifix code  Let  resp   be the set of nonempty proper prefixes  resp  suffixes  of and let be the incidence graph of  em  upshap e i    The graph is acyclic  that is a union of trees  em  upshap e ii    The trace on  resp  on  of a connected component of is a suffix  resp  prefix  code  em  upshap e iii    In particular  this trace on  resp  on  contains at most one right-special  resp  left-special  word  The last assertion follows from the second by Proposition propPrefixSpecial  We call a path reduced  reduced path   path  reduced  if it does not use equal consecutive edges  We prove by induction on that if and  resp  and  are connected by a reduced path of length in then are not prefix-comparable  resp  are not suffix-comparable   This shows that is acyclic  Indeed  if there were a cycle from to in then and would be prefix-comparable  This shows also that two words in the same trace on  resp  on  are not suffix-comparable  resp  are not prefix-comparable    hbt  sse tNw 0 Nh 0 Nframe n AHnb 0 ExtNL y NLangle 0 NLdist 1   20 8  0 -10   node s  20 6      node NLangle 180  q  0 3      node t  20 0     rawedge linecolor red  q s    rawedge linecolor red  q t     qquad qquad qquad qquad  20 24  0 0   node s  20 24      node NLangle 180  u1  0 21      node v2  20 18      node vdot  20 12      node vn  20 6      node NLangle 180  un  0 3      node t  20 0     rawedge linecolor red  u1 s    rawedge linecolor red  u1 v2    rawedge linecolor red  un vn    rawedge linecolor red  un t    A path on the left  and a path of length on the right  The property holds for  Indeed  a reduced path of length from to is of the form with  Since the path is reduced  and since is prefix  and are not prefix-comparable  see Figure figurelemmaSuite1  The proof for prefixes is similar  Let  A path of length from to is a sequence with and such that the words defined for by x  2i-1  u  i v  i   quad x  2i  u  i v  i 1   are in  Moreover  since the path is reduced  one has for  For let be the longest common prefix of  Since and since the code is prefix  the words and are not prefix-comparable  Arguing by contradiction  assume that and are prefix-comparable  By Lemma lemmaLCP we have for some indices with  Set and  Since are not prefix-comparable  the words are nonempty  Since their longest common prefix is empty  their initial letters are distinct  Thus is right-special  Similarly is right-special  Thus and are suffix-comparable  Since and are suffix-comparable  But and are connected by the path of length  By the induction hypothesis  and are not suffix-comparable  a contradiction  The proof that if and are connected by a path of length in then are not suffix-comparable is similar  Let be a bifix code and let be the set of proper prefixes of  Consider the equivalence on which is the transitive closure of the relation formed by the pairs such that for some  Such a pair corresponds  when to a path in the incidence graph of  Thus a class of is either reduced to the empty word or it is the trace on of a connected component of the incidence graph of  Consider the code of Example exampleIncidenceGraph above  The three classes of are the class of the empty word  and the two suffix codes which are the traces of connected components of the incidence graph on the set of nonempty proper prefixes of  These codes are and  They are shown in Figure figureSuffixMax   hbt  sse tNadjust wh AHnb 0 linecolor red   110 20  0 -8   node Nmr 0  babaabaaba  0 5     node abaabaaba  10 5     node baabaaba  20 5     node aabaaba  30 5     node Nmr 0  babaaba  30 -5     node abaaba  40 0     node baaba  50 0     node aaba  60 0     node Nmr 0  baba  60 -10     node aba  70 -5     node Nmr 0  baa  70 5     node ba  80 -5     node aa  80 5     node a  90 0     node Nmr 0  b  90 -10     node 1  100 -5    rawedge babaabaaba abaabaaba     rawedge abaabaaba baabaaba     rawedge baabaaba aabaaba     rawedge aabaaba abaaba     rawedge abaaba baaba     rawedge baaba aaba     rawedge aaba aba     rawedge aba ba     rawedge ELside r  ba a     rawedge a 1     rawedge ELside r  babaaba abaaba     rawedge ELside r  baba aba     rawedge baa aa     rawedge aa a     rawedge ELside r  b 1     sse tlinecolor blue   90 35  -10 -18   node Nmr 0  babaabaab  -10 -5     node abaabaab  0 -5     node Nmr 0  babaabaa  0 5     node baabaab  10 -5     node abaabaa  10 5     node aabaab  20 -5     node Nmr 0  babaab  20 -15     node baabaa  20 5     node aabaa  30 5     node Nmr 0  babaa  30 -3     node abaab  30 -10     node abaa  40 0     node baab  40 -10     node baa  50 0     node aab  50 -10     node Nmr 0  bab  50 -20     node aa  60 0     node Nmr 0  ba  60 -8     node ab  60 -15     node a  70 -5     node b  70 -15     node 1  80 -10    rawedge babaabaab abaabaab     rawedge babaabaa abaabaa     rawedge abaabaab baabaab     rawedge abaabaa baabaa     rawedge baabaab aabaab     rawedge baabaa aabaa     rawedge aabaab abaab     rawedge aabaa abaa     rawedge abaa baa     rawedge baa aa     rawedge aa a     rawedge a 1     rawedge ELside r  ba a     rawedge ELside r  babaab abaab     rawedge abaab baab     rawedge baab aab     rawedge aab ab     rawedge ab b     rawedge ELside r  b 1     rawedge ELside r  babaa abaa     rawedge ELside r  bab ab     rawedge ELside r  ba a     The two suffix codes which are classes of the equivalence  The following property relates the equivalence with the right cosets of  Let be a bifix code  let be the set of proper prefixes of and let be the subgroup generated by  For any implies  Since there is a path from to in the incidence graph of of length for some  If There is a word such that  Then and thus  The general case follows by induction  Let be the literal automaton of  see Section sectionAutomata  We show that the equivalence is compatible with the transitions of the automaton in the following sense  Let be a Sturmian set  Let be a bifix code and let be the set of proper prefixes of  Let and  If and if in the literal automaton of then  Let be the incidence graph of  Let and be such that and  If then and the conclusion holds  Thus we may assume that and that  Let be a path in with  The corresponding words in are  We may assume that the words are pairwise distinct  and that the are pairwise distinct  Moreover  since there exist words such that  The proof is in two steps  In the first step  we assume that and both start with  In the second step  we show that this condition is always fulfilled  Assume that and begin with  There are two cases  Case 1  Assume first that  Then and  If all words begin with then clearly the equivalence holds  Thus assume the contrary  and let be minimal such that begins with a letter distinct of and let be maximal such that begins with a letter distinct of  Then both words and are right-special  since starts with and starts with for some letter and similarly for  But since and are in the same trace on of a connected component of Lemma lemmaSuite implies that that is  But this contradicts the inequality  Case 2  Suppose now that  This implies that since is in and begins with  If then since and if they are distinct  are not prefix-comparable by Lemma lemmaSuite one and  If then is a path from to  recall that  Lemma lemmaSuite implies that and if they are distinct  are not prefix-comparable  Thus  one has again  In both cases  and therefore  We now show that the assumption that begins with a letter distinct of leads to a contradiction  the case where starts with a letter distinct from is handled symmetrically   In this case since is in and the word is right-special  Let be the largest integer such that begins with a letter distinct of for  If then is right-special  This contradicts Lemma lemmaSuite  iii   since and are distinct  because  elements of the trace on of a connected component of  If then and are right-special since and  We obtain again a contradiction since and are distinct 
Coset automaton
 Let be a Sturmian set and let be a bifix code  We introduce a new automaton denoted or for short  and called the coset automaton  coset automaton   automaton coset  of  Let be the set of classes of with the class of still denoted  The coset automaton of is the automaton with set of states and transitions induced by the transitions of the literal automaton of  Formally  for and one has in the automaton if there exist in the class and in the class such that in the automaton  Observe first that the definition is consistent since  by Lemma lemmaCompatible if and are nonempty and are in the same class then and are in the same class  Since the class is uniquely defined  the automaton is indeed deterministic  Observe next that if there is a path from to in the automaton labeled then there is a path from the class of to the class of labeled in   hbt   40 10  0 -5   node 1  0 0      node linecolor red  2  20 0   color red       node linecolor blue  3  40 0   color blue      rawedge curvedepth 3  1 2     rawedge curvedepth 3  2 1     rawedge curvedepth 3  2 3     rawedge curvedepth 3  3 2     rawloop loopangle 180  1     rawloop loopangle 0  3     The automaton  For the code of Example exampleIncidenceGraph the automaton has three states  State is the red class  that is the class containing and state is the blue class containing  The bifix code generating the submonoid recognized by this automaton is  Observe that the word is in but it is not in  The following result shows that the coset automaton of is the Stallings automaton of the subgroup generated by  Let be a Sturmian set  and let be a bifix code  The coset automaton is reversible and describes the subgroup generated by  Moreover where is the bifix code generating the submonoid recognized by  Let be the literal automaton of and Set  Let and be such that is nonempty  Let be elements of the classes and respectively  such that are nonempty  Then  To show that is reversible  it is enough to show that  Suppose first that  Then and thus since is isolated mod  Thus  Suppose next that  Then there is a path in the incidence graph of with and  We may assume that the nodes of the path are pairwise distinct  except for a possible equality  If all the words end with then  Otherwise  let be minimal such that ends with a letter distinct of and with be maximal such that ends with a letter distinct of  Then and are left-special and they are distinct since  This contradicts Lemma lemmaSuite  iii  since and are distinct elements of the same trace on the set of proper nonempty suffixes of  Thus the coset automaton is reversible  Let be the bifix code generating the submonoid recognized by  To show the inclusion consider a word  There is a path from to labeled in hence also in  Since the class of modulo is reduced to this path in does not pass by except at its ends  Thus is in  Let us finally show that the coset automaton describes the group  By Proposition propGeneratedGroup the subgroup described by is equal to  Set  Since we have  To show the converse inclusion  let us show by induction on the length of that  for there is a path from the class of to the class of in with label then  By Proposition propTheta this holds for  Next  assume that it is true for and consider with  Assume that there are states such that there there is a path from the class of to the class of in with label and an edge from the class of to the class of in with the label  By induction hypothesis  we have  Next  by definition of there is an such that  If then and by Proposition propTheta we have and  Thus  Otherwise  and because the class of is a singleton  In this case   This property shows that if then that is  Thus and finally
Return words
 Let be a factorial set  For define  Gamma F u   z in F mid uz in A  u cap F     qquad  Gamma  F u   z in F mid zu in uA   cap F  and R F u   Gamma F u  setminus  Gamma F u A       qquad R  F u   Gamma  F u  setminus A   Gamma  F u      When for an infinite word the sets and are respectively the set of right return words  right return word  to and first right return words  return word first right   first right return word  to in and and are respectively the set of left return words  left return word  to and first left return words  return word first left   first left return word  to in  The relation between and is simply Words in the set are called complete return words  complete return words  in JustinVuillon2000  When there is no ambiguity  we will call the  first  right return words simply the  first  return words  omitting the  right  specification  Let be the Fibonacci set  The sets and are given below for the first small words of  u 	1 	a 	b 	aa 	ab 	ba 	aab 	ab a	ba a	bab
  hline  multiro w2      	a 	a 	ab 	baa 	ab 	ba 	aab 	ba 	baa 	aabab
 	b 	b a	aa b	baba a	aa b	ab a	abaa b	ab a	baba a	aabaabab
  hline  multiro w2      	a 	a 	ba 	aab 	ab 	ba 	aab 	ab 	ba a	babaa
 	b 	a b	ba a	aaba b	ab a	ba a	aaba b	ab a	baab a	babaabaa
 Vuillon has shown in Vuillon2001 that is a Sturmian word if and only if has exactly two elements for every factor of  Another proof of this result is given by Justin and Vuillon in JustinVuillon2000  In fact  they show in JustinVuillon2000 the following theorem  Since this result is not exactly formulated in JustinVuillon2000 as stated here  we show how it follows easily from their article  Let be a Sturmian set  For any word the set  and the set  is a basis of the free group  By Equation  eqre feqAutomo   the sets and are conjugate in the free group  Conjugacy by an element is an automorphism of the free group  It follows that is a basis if and only if is a basis  Thus  it suffices to prove the claim for  We quote the following result of with the notations of Section subsection-episturmian  Let be a standard strict episturmian word over let be its directive word  and let be its sequence of palindrome prefixes  em  upshap e i    The first left return words to are the words for  em  upshap e ii    For each factor of there exist a word and an integer such that the first left return words to are the words where ranges over the first left return words to  We may assume that for some standard and strict episturmian word  By Proposition propJustinVuillon  i   the set of first left return words to is the image of the alphabet by the endomorphism  It is easily seen that these endomorphisms define automorphisms of the free group  We deduce that the set of first left return words to is a basis of the free group on  By Proposition propJustinVuillon  ii   the set of first left return words to is a basis  too  This ends the proof 
Proof of the main result
 Some preliminary results are needed for the proof of Theorem theoremGroups  Let be a Sturmian set and let be a finite -maximal bifix code  Then  We have  To show the converse inclusion  consider the bifix code generating the submonoid re -cog -ni -zed by the coset automaton associated to  Let us show that  By Lemma lemmaBidet we have and thus  Since is an -maximal bifix code  this implies that  Since any reversible automaton is minimal and since the automaton is reversible by Lemma lemmaBidet it is equal to the minimal automaton of  Let be the subgroup generated by  By Proposition lemmaExercise612 we have  This shows that ngle X rangle cap F subset K cap F  K cap A   cap F Z   cap F  X   cap F    The first inclusion holds because implies  The last equality follows from the fact that if with then each is in hence in  Thus which was to be proved  We will use the following consequence of Proposition propositionHcapF  Let be a Sturmian set and let be a finite -maximal bifix code  Each right coset of the subgroup generated by contains at most one right-special proper prefix of  Set  Let be the set of those proper prefixes of the words of which are right-special  Let us show that if belong to the same right coset  then  We may assume that  Since one has  Consequently  and thus  By Proposition propositionHcapF since this implies that and thus since is a proper prefix of  Assume first that is an -maximal bifix code of -degree  Let be the set of proper prefixes of  Let be the set of words in which are right-special  Let be the subgroup generated by  By Lemma lemmadSpecial there is a right-special word such that  The suffixes of which are in are the elements of  By Theorem theoremDegree the word is not an internal factor of   hbt  sse tNadjust wh AHnb 0   50 15  0 -5   node uh  20 10    node endh  60 10     node u  0 5    node v  40 5    node end  60 5     node q  10 0    node qend  40 0    node r  30 -5    node endr  60 -5    rawedge uh endh     rawedge u v     rawedge v end     rawedge q qend     rawedge r endr     A word  Let V  v in A  circ mid Qv subset HQ     Any defines a permutation of  Indeed  suppose that for one has for some  Then is in  This forces and thus by Corollary corollaryCosets  The set is a subgroup of  Indeed   Next  let  Then for any since defines a permutation of there is a such that  Then  This shows that  Next  if then and thus  We show that the set is contained in  Indeed  let and  Since is a suffix of is a suffix of and since is in  by definition of   also is in  The fact that is -maximal implies that there is a word such that  We verify that the word is a suffix of  Since there is a word such that  Consequently  is a suffix of and in fact the word is a suffix of  Indeed  one has since otherwise is in and this is not the case  Thus we have  see Figure figGamma  Since and we have  Thus  By Theorem propositionGamma the group generated by is  Since and since is a subgroup of we have  Thus for any  Since we have in particular  Thus  Since and since the right cosets for are pairwise disjoint  this shows that is a subgroup of index  By Theorem theoremBifixd 1 and in view of Schreier s Formula  is a basis of  Assume conversely that the bifix code is a basis of the group and that has index  Since is a basis  by Schreier s Formula  we have where  The case is straightforward  thus we assume  By Theorem theoremCompletion there is a finite -maximal bifix code containing  Let be the -degree of  By the first part of the proof  is a basis of a subgroup of index of  In particular  it has elements  Since we have and thus  On the other hand  since is included in is a multiple of and thus  We conclude that and thus that  Let be the Fibonacci set  Let be the bifix code shown on Figure figureCodeGiuseppina  The right-special proper prefixes of the words of are the four suffixes of and are indicated in black on the figure   hbt  sse tAHnb 0 Nadjust wh   60 35  0 3   node fillgray 0  1  0 20     node fillgray 0  a  10 30    node b  10 10     node Nmr 0  aa  20 35    node ab  20 25    node fillgray 0  ba  20 10     node fillgray 0  aba  30 25    node baa  30 15    node bab  30 5     node abaa  40 30    node Nmr 0  abab  40 20     node Nmr 0  baab  40 15    node Nmr 0  baba  40 5     node abaab  50 30    node Nmr 0  abaaba  60 30    rawedge 1 a     rawedge ELside r  1 b     rawedge a aa     rawedge a ab     rawedge b ba     rawedge ab aba     rawedge ba baa     rawedge ELside r  ba bab     rawedge aba abaa     rawedge ELside r  aba abab     rawedge ELside r  baa baab     rawedge bab baba     rawedge abaa abaab     rawedge abaab abaaba     An -maximal bifix code of -degree 4  The states of the coset automaton are the sets and  The code has -degree  Each state is represented by its right-special factor in Figure figureGroup   hbt   30 30  0 -3   node 1  0 20     node a  20 20      node aba  0 0     node ba  20 0     rawedge curvedepth 3  1 a     rawedge curvedepth 3  a 1     rawedge curvedepth 3  1 aba     rawedge curvedepth 3  aba 1     rawedge curvedepth 3  a ba     rawedge curvedepth 3  ba a     rawedge curvedepth 3  aba ba     rawedge curvedepth 3  ba aba     The associated coset automaton  We end this section with a combinatorial consequence of Theorem theoremGroups  Let be a Sturmian set on an alphabet with letters and let be a finite -maximal bifix code of -degree  Let  resp   be the set of proper prefixes  resp  suffixes  of  Then  sum  x in X |x|  Card P   Card S   k-2 d  We will use the following proposition  of independent interest  Let be a Sturmian set and let be a finite -maximal bifix code of -degree  The coset automaton is a group automaton with states  Each state of other than is an -maximal suffix code  Let be the literal automaton recognizing and let be the coset automaton of  By Lemma lemmaBidet the automaton is reversible and describes the subgroup generated by  By Theorem theoremGroups the subgroup has index in  Since is reversible  it is minimal  Propositions propGroupCode and propStallings show that is a group automaton  Its number of states is since a group automaton which describes a subgroup of index has states by Proposition propositionGroupAutomaton  Finally  consider and let  Let us show that any is suffix-comparable with an element of  We may assume that is longer than any word of  Since is a group automaton  there is an such that  Since is longer than any word of the path from to labeled passes through state  Thus has a parse such that and thus has a suffix in  This shows that is an -maximal suffix code  Note that the fact that the set of nonempty proper prefixes of is a disjoint union of -maximal suffix codes is also a consequence of the dual statement of Theorem theoremDisjointUnion  medskip Let be the subgroup generated by  By Theorem theoremGroups the set is a basis of and the index of is equal to  Let be the incidence graph of  Let be the set of edges of  One has  Card E   sum  x in X  |x|-1   sum  x in X |x|- Card X   sum  x in X |x|- k-1 d-1    By Proposition lemmaCosets the classes of are the set and -maximal suffix codes denoted for  Each of the latter is the trace on of a connected component of  Let be the subgraph of induced by its connected component  By Lemma lemmaSuite is a tree  Similarly  let be the trace on of the connected component  Let be the set of edges of  Since is a tree  we have for  Finally  Card E 	  sum  i 1   d-1  Card E i   sum  i 1   d-1   Card P i   Card S i -1 
 	  Card P setminus1   Card S setminus1 - d-1     whence the result 
Syntactic groups
 Let be a recurrent subset of  In this section  we introduce the notion of -group of a bifix code of finite -degree  It is a permutation group of degree  We investigate the relation between this group and the notion of group of a maximal bifix code  Theorem theoremGroupCodes  We use Theorem theoremGroups to prove a new result on the syntactic groups of bifix codes  any transitive permutation group of degree and with generators is a syntactic group of a bifix code with elements  Theorem newTheorem
Preliminaries
 We first recall the basic terminology on groups in monoids  see BerstelPerrinReutenauer2009 for a more detailed exposition   We are mainly concerned with monoids of maps from a set into itself  The maps considered in this section are partial maps  Let be a monoid  A group in  group in a monoid  is a subsemigroup of which is isomorphic to a group  Note that the neutral element of a group contained in needs not be equal to the neutral element of  A group in is maximal  group maximal   maximal group  if it not included in another group in  Let be a group in a monoid of partial maps from a set into itself  All elements of have the same image  The restriction of the elements of to is a faithful representation of as a permutation group on  Two elements have the same image  Indeed  let be the inverse of in  Then and thus the image of is contained in the image of  The converse inclusion is shown analogously  Then is a permutation group on the common image of its elements  Indeed  let be the neutral element of  Then for any let be such that  Then  This shows that is the identity on  Next  for any the inverse of is such that  Thus is a permutation on  Let be such that they have the same restriction to  Then for each since  Since and we obtain  This shows that the representation of by permutations on is faithful  Let be a group in a monoid of maps from into itself as above  The canonical  canonical representation   representation canonical  representation of by permutations is the restriction of the maps in to their common image  A syntactic group  syntactic group   group syntactic  of a prefix code is the canonical representation by permutations of a maximal group in the monoid of transitions of the minimal automaton of  Let be a prefix code and let  A syntactic group of is called special  special syntactic group  if is a cyclic submonoid of  In particular a special syntactic group is cyclic  The degree  degree of a permutation group   permutation group degree  of a permutation group on a set is the cardinality of  Recall that the group is transitive  transitive permutation group   permutation group transitive  if for any there is some such that  A permutation group on a set and a permutation group on a set are equivalent  equivalent permutation group   permutation group equivalent  if there exists a bijection and an isomorphism such that  for all and one has  beta rg   beta r  sigma g     in other terms  if the diagram of Figure commdiagram is commutative for all   hbt  sse tNframe n Nadjust wh   30 25   node 1  0 20     node 2  30 20      node 3  0 0     node 4  30 0     rawedge ELside r  1 2     rawedge 3 4     rawedge 1 3     rawedge 2 4     Equivalent permutation groups  Let us recall the notation concerning Green relations in a monoid  see BerstelPerrinReutenauer2009  We denote by the equivalence in defined by if generate the same right ideal  i e  if  We denote by the -class of  Symmetrically  we denote by the equivalence defined by if generate the same left ideal  i e  if  We denote by the -class of  It is well known that the equivalences and commute  We denote by the equivalence  Finally  we denote by the equivalence  A -class is regular  D-class  regular  -class regular  if it contains an idempotent  In this case  there is at least an idempotent in each -class of and in each -class of  The following statement is known as Clifford and Miller s Lemma  Clifford and Miller s Lemma   For one has if and only if contains an idempotent  Assume that is a monoid of maps from a finite set into itself  If are -equivalent  then they have the same image  If they are -equivalent  then they have the same nuclear equivalence  the nuclear equivalence of a partial map from into itself is the partial equivalence  for which are equivalent if is defined on and and  If are -equivalent  they have the same image and the same nuclear equivalence  The converse is not true but it holds in the following important particular case  Let be a monoid of maps from a finite set into itself  Let be an idempotent  An element of is in the -class of if and only if it has the same nuclear equivalence and the same image as  If and are -equivalent  they have the same nuclear equivalence and the same image  Conversely  we have since is the identity on its image  For any implies that and are in the same class of  This implies that  Thus  Finally  the restriction of to is a permutation  Indeed  for implies which forces  Let be such that the restriction of to is the identity  Then and are two idempotents with the same nuclear equivalence and the same image  This implies that they are equal  Thus and are in the same -class  Let be a recurrent set and let be a bifix code of finite -degree  Let be a simple automaton recognizing  We set and we denote by the transition monoid of  For a word we denote by the image  image of a word   word image  of with respect to that is the set  The rank  rank word   word rank  of  with respect to the automaton  is the number  Then is also the image of the map  recall that the action of is on the right of the elements of   and the rank of is also the rank of  Clearly for all  The set of elements of of rank is included in a regular -class of  We use the following lemmas  A word which has parses with respect to has rank with respect to  Moreover  is the set of states for all such that there is a parse of  For all there is a unique proper prefix of which is a suffix of and such that  Consider first two states and suppose that  Since is simple  it is trim  Consequently there exist two words such that and  It follows that  Since has parses  by Theorem theoremDegree it is not an internal factor of a word in  Thus there is a parse of such that  Then  The relation is a function  Indeed  let us show that if and are two distinct parses of then  Assume the contrary  Then we have for the same word  Since are suffixes of they are suffix-comparable and thus since is bifix  This is impossible if the parses are distinct  Of course  the function is injective since is deterministic  Conversely  let be a parse of  Since is an -maximal bifix code  there exist by Theorem theoremEquivMax words such that  Thus we have  Consequently  This shows that  Let be a word  If then for all such that  Since is -thin  there exists which is not a factor of a word in  This word has parses  Assume  Since is recurrent  there exists a word such that  Then also has parses  By Lemma lemmaRank1 this implies that the rank of is  Since one has   medskip Let be two words of rank  Set and  Let be such that  We show first that and  For this  let be such that  Set  By Lemma lemmaRank2 the rank of is  Since this implies that the images are equal  Consequently  the restriction of to is a permutation  Since is finite  there is an integer such that is the identity on  Set and  Then  since is the identity on one has  Thus and since it follows that and are -equivalent  Similarly and are -equivalent  Indeed  set  Then  Since is a factor of and has rank it follows that  Therefore  has rank and consequently the images and are equal  There is an integer such that is the identity on  Set  Then with  Since one has  Thus are -equivalent  and  Set  Then and  with the previous notation  so  Thus and by Clifford and Miller s Lemma  contains an idempotent  Thus the -class of and is regular 
Group of a bifix code
 Let be a monoid  The -class of an idempotent is denoted  It is the maximal group contained in and containing  All groups for idempotent in a regular -class are isomorphic  The structure group  group structure   structure group   or Sch  utzenberger group  of is any one of them  When is a monoid of maps from a set into itself  the canonical representations of the groups are equivalent permutation groups  See  We then also consider the structure group as a permutation group  Let be a recurrent set and let be a bifix code of finite -degree  Let be a simple automaton recognizing  Set  The structure group of the -class of elements of rank of is a permutation group of degree  By Proposition 9 5 1 in BerstelPerrinReutenauer2009 this group does not depend on the choice of the simple automaton recognizing  It is called the - group  F-group  -group  of the code and denoted  When the group is the group of the code defined in BerstelPerrinReutenauer2009  Indeed  in this case  the -class of elements of rank coincides with the minimal ideal of the monoid  The following example shows that the -group of an -maximal bifix code is not always transitive  Let and let  Then is an -maximal bifix code of -degree  It can be verified easily that the syntactic monoid of contains only trivial subgroups  see also Exercises 7 1 1  7 2 1 in BerstelPerrinReutenauer2009  Thus is reduced to the identity   hbt  sse tAHnb 0 Nadjust wh   60 35  0 3   node 1  0 20     node a  10 30     node b  10 10      node aa  20 35     node ab  20 25     node ba  20 10      node aba  30 25     node baa  30 15     node bab  30 5      node abaa  40 30     node abab  40 20      node baab  40 15     node baba  40 5      node abaab  50 30     node abaaba  60 30     rawedge 1 a     rawedge ELside r  1 b     rawedge a aa     rawedge ELside r  a ab     rawedge b ba     rawedge ab aba     rawedge ba baa     rawedge ELside r  ba bab     rawedge aba abaa     rawedge ELside r  aba abab     rawedge ELside r  baa baab     rawedge bab baba     rawedge abaa abaab     rawedge abaab abaaba     An -maximal bifix code of -degree 4  We consider again the code of Example exampleCodeGiuseppina  The minimal automaton of is represented on Figure figureCodeGiuseppina2  ef r b  raisebox 0 8ex      ef v h vphantom  gl     r|   l   c|   l   c|   l   c| 
 1|2 6|3| 7	 vh 	 	 	a  2	 vh r b
 1|2|4 9|5  8	 vh r b	b a	 vh r b	 	 v h	 b
 1|2 6|3 8|4  7	 vh r b	aba 	 v h	 	 vh r b	ab
 The -class of rank  We have represented on Figure figDclass the -class of elements of rank meeting  It is composed of three -classes and three -classes  Each -class is represented by a column and each -class by a row  On top of each column  we have indicated the common image of the its elements  On the left of each row  we have indicated the common nuclear equivalence of its elements  recall that two elements are equivalent for the nuclear equivalence if and only if they have the same image   The -classes containing an idempotent are indicated by a star  Each -class has four elements  and five of them are groups  this happens when the image is a system of representatives of the nuclear equivalence   For instance  the five classes in the nuclear equivalence of are and and the -class of  the image of  is composed of the following elements    upshape Word   	   upshape Permutation  
 hline b a	  18  24 
 baab a	 12  48 
 bab a	 1 
 babaab a	 14  28  The structure group of this -class is the Abelian group  It is the -group of the code  The aim of this section is to prove the following theorem  Any transitive permutation group of degree which can be generated by elements is a syntactic group of a bifix code with elements  Theorem newTheorem was known before in particular cases  In Perrin1981 it is shown that any transitive permutation group is a syntactic group of a finite bifix code  The bound on the cardinality of the bifix code is proved for the case of a group generated by a -cycle and another permutation  In Rindone1987 it is proved that for an Abelian group of rank and order there exists a bifix code such that  The proof is based on the fact that the Cayley graph of an Abelian group contains a Hamiltonian cycle  Let us call minimal rank of a group the minimal cardinality of a generating set for  Theorem newTheorem is related to the following conjecture Perrin1981    sl Let be a finite bifix code and let be a transitive permutation group of degree and minimal rank  If is a syntactic group of then   Theorem newTheorem shows that the lower bound is sharp  The following result  which is from PerrinRindone2003 shows that the conjecture holds for  Let be a permutation group of degree  If is a nonspecial syntactic group of a finite prefix code then  Theorem theoremPR is clearly not true for special syntactic groups since is a syntactic group of for any  Theorem newTheorem is a consequence of the following theorem which can be viewed as a complement to Theorem proposition1  The proof itself makes use of Theorem theoremGroups  Let be a group code of degree  Let be a Sturmian set  The set is an -maximal bifix code of -degree and  The fact that is an -maximal bifix code of -degree results from Corollary newCorollary  Let us show that  Let be the minimal automaton of  Set and  Thus is a permutation group equivalent to  Let be the minimal automaton of  Set  Denote by the image of with respect to  Thus  Let be a word with parses with respect to  Let  By Lemma lemmaRank1 the word has rank and thus  Let be the set of first return words to  By Theorem propositionGamma the set is a basis of the free group  For any the restriction of to is a permutation of  Indeed  implies  Since the set has elements by Lemma lemmaRank2  Thus  Since this proves the claim  Let be an idempotent in  The restriction of to is the identity  Any long enough element of has as a suffix  Thus the image of is  Moreover  since and and belong to the same -class and thus to the -class  Thus belongs to the -class of which contains the elements of rank in  Let be the maximal group contained in which contains  It is a permutation group on which is equivalent to  For let be the restriction of to the set  For any has the same nuclear equivalence and the same image as  By Proposition propIdempotent it implies that they are in the same -class  Thus is in  Since and have the same restriction to and since belongs to the -class of is a morphism from into the permutation group  Since generates this morphism is surjective  Indeed  if let be such that with  Then  Since is a finite group  Thus  Let us show that and are equivalent as permutation groups  For this  let us define a bijection as follows  Let be the set of proper prefixes of the words of and let be the set of elements of which are suffixes of  For there is a unique such that by Lemma lemmaRank1  Set  We show that is injective  Let be such that  Assume that  Since are suffix-comparable  we have  Since and since is a permutation  we have and thus  Since is in and since this implies and thus  This shows that and thus that is injective  Since we have shown that is a bijection  Let us verify that for any and we have Let us first prove  eqre feqdiagram  for  For this  let be such that  The states exist by Lemma lemmaRank1  Then i varphi y  j    iff   1 varphi qy  1 varphi t    iff   qy in X  t  The last equivalence holds because for the word such that  But since is a suffix of and thus  This forces  Since we have qy in X  t    iff   qy in Z  t and thus  we obtain i varphi y  j    iff   qy in Z  t    iff    beta i  psi y   beta j   This proves  eqre feqdiagram  for  Next  let us show that if satisfy  eqre feqdiagram  for all the same is true for  Assume first that for one has  Since the restrictions of to are permutations  there is a unique such that and  Then  since satisfy  eqre feqdiagram   we have and  Thus  Conversely  assume that  Since is a bijection from onto there is a unique such that  Then  By  eqre feqdiagram   we have and whence  This proves that satisfies  eqre feqdiagram   Equation  eqre feqdiagram  shows that we may define a morphism from to by for such that  This map is injective  Indeed  if let be such that and  Then  and imply that  By  eqre feqdiagram   implies that and thus  Since generates the free group the map is surjective  Indeed  for any we have with and  Thus with  Finally  the commutative diagrams of Figure diagram show that the pair is an equivalence of permutation groups   hbt  sse tNframe n Nadjust wh   80 25   node 1  0 20     node 2  30 20      node 3  0 0     node 4  30 0     rawedge 1 2     rawedge 3 4     rawedge 1 3    rawedge 2 4     node I1  50 20     node I2  80 20      node R1  50 0     node R2  80 0     rawedge I1 I2     rawedge R1 R2     rawedge I1 R1     rawedge I2 R2     The equivalence of and  We illustrate the proof of Theorem theoremGroupCodes  Let be the group code of degree recognized by the automaton of Figure figureGroupX  It is the automaton of Figure figureGroup with more convenient labels for the states   hbt   30 30  0 -3   node 1  0 20     node a  20 20      node aba  0 0     node ba  20 0     rawedge curvedepth 3  1 a     rawedge curvedepth 3  a 1     rawedge curvedepth 3  1 aba     rawedge curvedepth 3  aba 1     rawedge curvedepth 3  a ba     rawedge curvedepth 3  ba a     rawedge curvedepth 3  aba ba     rawedge curvedepth 3  ba aba     A group automaton  It is clear the is  Let be the Fibonacci set  The code is the code of Example exampleCodeGiuseppina  The minimal automaton of is represented on Figure figureCodeGiuseppina2  Let us chose  It has rank and  One gets  Next and  The function maps to respectively  The following example shows that Theorem theoremGroupCodes does not hold for the set of factors of an episturmian word which is not strict  Let and be as in Example exampleNotStrict  The bifix code has -degree  Let be the minimal automaton of represented on Figure figureExNonStrict  The image of is the set  The submonoid is generated by and  The restrictions to of and are  1  14  25  6  4  21  32  13   quad  1  6  14  25  4  13  21  32   These permutations generate a group which has two orbits  and  The restriction to each orbit is isomorphic to  Thus the -group of is  However where is a group code such that  Let be a transitive permutation group of degree and let be a group code on an alphabet with letters such that  Let be a Sturmian set on the alphabet and let  Then  by Theorem theoremGroupCodes and  by Theorem theoremBifixd 1 has elements 
Acknowledgments
 We wish to thank Mike Boyle  Aldo De Luca  Thierry Monteil  Patrice S  e  ebold  Martine Queff  elec and Gw  ena  el Richomme for their help in the preparation of this manuscript   NeedsTeXForma tLaTeX2e   ProvidesPackag egastex  2004 05 02 v2 7   newif ifgastexslide stexslidefalse  DeclareOptio nslide   global stexslidetrue   DeclareOptio npaper   global stexslidefalse   ProcessOptions  RequirePackag ecalc trig   specia lheader gastex pro   newcounte rcnt a  newcounte rcnt b  newcounte rcnt c   newdimen im x  newdimen im y  newbox emp box  newdimen  my unit  my unit 0 01mm   catcode t 12 catcode p 12 gdef no PT 1pt  1   ef strip PT  1 expandafter no PT he 1 space  ef s initp s BP s dash  line width setlinewidth space  ef s AHpara m AH nb AH d AH angle AH L AH l  ef s ATpara m AT nb AT d AT angle AT L AT l  ef s ATnu l0  AT d AT angle AT L AT l  ef s gobble  1  ef sset  1 s set 1 	  ef s set 1  2   ignorespaces   ifundefined gasset  1    PackageWarning gastex  Parameter  1 undefined       csname gasset  1 csname  2     ifnextcha r 	 s gobble   s set   ef sset Nw  1  setcounter cnt a  1  rati o 1 unitlength    my unit    edef N  w hecnt a   ef sset Nh  1  setcounter cnt a  1  rati o 1 unitlength    my unit    edef N  h hecnt a   ef sset Nmr  1  setcounter cnt a  1  rati o 1 unitlength    my unit    edef N m r hecnt a    newif if wadjust  newif if hadjust  newif if nadjust ef sset Nadjust  1   wadjustfalse   hadjustfalse sset  Nadjust   1	  ef sset  Nadjust  1   ifundefined if  1adjust    PackageWarning gastex  Node adjust  1 undefined       csname   1adjusttrue csname    ifnextcha r 	 s gobble   sset  Nadjust   ef sset Nadjustdist  1  setcounter cnt a  2  rati o 1 unitlength    my unit    edef N adjustdis t hecnt a    newif if frame  newif if fill  newif if ExtNL ef flag  y relax  ef flag  n relax  ef sset Nframe  1   ifundefined flag  1    PackageWarning gastex  Nframe value should be y or n       if 1y   frametrue  else   framefalse  fi   ef sset Nfill  1   ifundefined flag  1    PackageWarning gastex  Nfill value should be y or n       if 1y   filltrue  else   fillfalse  fi   ef sset ExtNL  1   ifundefined flag  1    PackageWarning gastex  ExtNL value should be y or n       if 1y   ExtNLtrue  else   ExtNLfalse  fi   ef sset NLangle  1 edef NL angle  1   ef sset NLdist  1  setcounter cnt a  1  rati o 1 unitlength    my unit    edef NL dis t hecnt a    newif if imark  newif if fmark  newif if rmark  newif if nmark ef sset Nmarks  1   imarkfalse   fmarkfalse   rmarkfalse sset  Nmarks   1	  ef sset  Nmarks  1   ifundefined if  1mark    PackageWarning gastex  Node mark  1 undefined       csname   1marktrue csname    ifnextcha r 	 s gobble   sset  Nmarks   ef sset ilength  1  setcounter cnt a  1  rati o 1 unitlength    my unit    edef i lengt h hecnt a   ef sset iangle  1 edef i angle  1   ef sset flength  1  setcounter cnt a  1  rati o 1 unitlength    my unit    edef f lengt h hecnt a   ef sset fangle  1 edef f angle  1   ef sset rdist  1  setcounter cnt a  1  rati o 1 unitlength    my unit    edef rep dis t hecnt a   ef sset sxo  1  setcounter cnt a  1  rati o 1 unitlength    my unit    edef E sx o hecnt a   ef sset syo  1  setcounter cnt a  1  rati o 1 unitlength    my unit    edef E sy o hecnt a   ef sset exo  1  setcounter cnt a  1  rati o 1 unitlength    my unit    edef E ex o hecnt a   ef sset eyo  1  setcounter cnt a  1  rati o 1 unitlength    my unit    edef E ey o hecnt a   ef sset curvedepth  1  setcounter cnt a  1  rati o 1 unitlength    my unit    edef curve dept h hecnt a   ef sset loopdiam  1  setcounter cnt a  1  rati o 1 unitlength    my unit    edef loop dia m hecnt a   ef sset loopangle  1 edef loop angle  1    newif if loopCW ef sset loopCW  1   ifundefined flag  1    PackageWarning gastex  loopCW value should be y or n       if 1y   loopCWtrue  else   loopCWfalse  fi   ef sset AHnb  1 edef AH nb  1 space   ef sset AHdist  1 im x  1 unitlength  edef AH d  strip PT im x   ef sset AHangle  1 edef AH angle  1 space   ef sset AHLength  1 im x  1 unitlength  edef AH L  strip PT im x   ef sset AHlength  1 im x  1 unitlength  edef AH l  strip PT im x   ef sset ATnb  1 edef AT nb  1 space   ef sset ATdist  1 im x  1 unitlength  edef AT d  strip PT im x   ef sset ATangle  1 edef AT angle  1 space   ef sset ATLength  1 im x  1 unitlength  edef AT L  strip PT im x   ef sset ATlength  1 im x  1 unitlength  edef AT l  strip PT im x   ef ELside  l relax  ef ELside  r relax  ef sset ELside  1   ifundefined ELside  1    PackageWarning gastex  ELside value should be l or r       edef EL s  1    ef sset ELpos  1  ifnum 1>100  PackageWarning gastex  ELpos value should be between 0 and 100     else ifnum 1<0  PackageWarnin ggastex  ELpos value should be between 0 and 100     else edef EL  p 1  fi fi  ef sset ELdist  1  setcounter cnt a  1  rati o 1 unitlength    my unit    edef EL dis t hecnt a    newif if ELdistC ef sset ELdistC  1   ifundefined flag  1    PackageWarning gastex  ELdistC value should be y or n       if 1y   ELdistCtrue  else   ELdistCfalse  fi   ef s rgb mode lsetrgbcolor  ef s cmyk mode lsetcmykcolor  ef s gray mode lsetgray  ef s color 1  2  ifundefined gas  1 model    PackageWarning gastex  Color model   1  not supported       ef s tmp col   s recode  2 	   edef s tmp co l s tmp col csname gas  1 model csname   ef s recode 1   edef s tmp col  s tmp col  1     ifnextcha r 	 s gobble   s recode   ef sset linegray  1 edef line color  1 setgray space   ef sset linecolor  1  ifundefined extractcolorspec     ifundefined  string color   1    PackageWarning gastex  Color  1 undefined       edef line color  1 space      extractcolorspec  1   s tmp color   expandafter s color s tmp color  edef line colo r s tmp col space    ef sset fillgray  1  filltrue edef fill color  1 setgray space   ef sset fillcolor  1  ifundefined extractcolorspec     ifundefined  string color   1    PackageWarning gastex  Color  1 undefined        filltrue edef fill color  1 space      extractcolorspec  1   s tmp color   expandafter s color s tmp color   filltrue edef fill colo r s tmp col space    ef sset linewidth  1 im x  1 unitlength  edef line width  strip PT im x   ef sset dash  1 sset  dash  1  ef sset  dash 1  2 ef s dash    s convert 0  1 	 im x  2 unitlength  edef s das h s dash   strip PT im x setdash space   ef s convert 1   im x  1 unitlength  ifdim im x 0pt else edef s dash  s dash strip PT im x  fi   ifnextcha r 	 s gobble   s convert   ef sset arcradius  1 im x  1 unitlength  edef arc radius  strip PT im x   ef sset polyangle  1 edef poly angle  1    unitlength 1mm sse tNw 8 Nh 8 Nmr 4  sse tNframe y  sse tfillgray 0 Nfill n  sse tExtNL n NLangle 90 NLdist 0  sse tiangle 180 ilength 5  sse tfangle 0 flength 5  sse trdist 0 7  sse tNmarks n  sse tNadjustdist 1 Nadjust n  sse tsxo 0 syo 0 exo 0 eyo 0  sse tcurvedepth 0  sse tloopdiam 8 loopangle 90 loopCW y  sse tAHnb 1 AHdist 1 41 AHangle 20 AHLength 1 5 AHlength 1 41  sse tATnb 0 ATdist 1 41 ATangle 20 ATLength 1 5 ATlength 1 41  sse tELside l ELpos 50 ELdist 1  sse tlinegray 0  sse tlinewidth 0 14 dash   0  sse tarcradius 0 polyangle 0   ifgastexslide sse tNw 12 Nh 12 Nmr 6 ilength 8 flength 8 rdist 1 loopdiam 12  sse tlinewidth 0 21 AHdist 2 1 AHLength 2 25 AHlength 2 1  sse tATdist 2 1 ATLength 2 25 ATlength 2 1   fi ef rpnode 1  2   3   4   5    ifnextchar   process rpnodeopt   rp node  1  2   3   4   5    ef process rpnodeopt  1   s set 1 	 rp node  ef rp node  1   2  3   4  5   6   global expandafter edef csname node  1 w csname -1   setcounte rcnt a  1  rati o 2 unitlength    my unit    global expandafter edef csname node  1 x csnam e hecnt a   setcounte rcnt a  1  rati o 3 unitlength    my unit    global expandafter edef csname node  1 y csnam e hecnt a   global expandafter edef csname node  1 n csnam e 4   setcounte rcnt a  1  rati o 5 unitlength    my unit    global expandafter edef csname node  1 rad csnam e hecnt a   global expandafter edef csname node  1 a csnam e poly angle  im x  csname node  1 x csname  my unit im y  csname node  1 y csname  my unit  edef ps pat h strip PT im x strip PT im y csname node  1 n csname space  im x  csname node  1 rad csname  my unit  edef ps pat h ps path  strip PT im x  csname node  1 a csname space   edef ps pat h ps path  arc radius 0  psrpolygonpath space   global expandafter edef csname node  1 path csnam e ps path   put 0 0   special   s initps  if fill 	  fill color  csname node  1 path csname fill 	 fi  if frame  line color  csname node  1 path csname stroke 	 fi     if imark rk  1   fi  if fmark  fmark  1   fi  if rmark ark  1   fi  nodelabel  1   6     ef node 1  2   3  4   5    ifnextchar   process nodeopt   i node  1  2   3  4   5    ef process nodeopt  1   s set 1 	 i node  ef i node  1   2  3   4 t node  1   2  3   4  raw node  1   4   ef t node  1   2  3   4   setbox emp box hbox  selectfont  4   if wadjust  setcounte rcnt a   N adjustdist    wd emp box    my unit   edef N  w hecnt a   fi  if hadjust  setcounte rcnt a   N adjustdist     ht emp box  p emp box     my unit   edef N  h hecnt a   fi  global expandafter edef csname node  1 w csnam e N w   global expandafter edef csname node  1 h csnam e N h   ifnum N h< N w 	 setcounte rcnt a   N h 2   else 	 setcounte rcnt a   N w 2   fi  ifnum N mr< hecnt a setcounte rcnt a   N mr  fi  global expandafter edef csname node  1 r csnam e hecnt a   setcounte rcnt a  1  rati o 2 unitlength    my unit    global expandafter edef csname node  1 x csnam e hecnt a   setcounte rcnt a  1  rati o 3 unitlength    my unit    global expandafter edef csname node  1 y csnam e hecnt a  im x  2 unitlength  edef ps pat h strip PT im x  im x  3 unitlength  edef ps pat h ps path  strip PT im x  im x  N w  my unit  edef ps pat h ps path  strip PT im x  im x  N h  my unit  edef ps pat h ps path  strip PT im x  im x  N mr  my unit  edef ps pat h ps path  strip PT im x   edef ps pat h ps path  psovalpath space   global expandafter edef csname node  1 path csnam e ps path     ef raw node  1   2   put 0 0   special   s initps  if fill 	  fill color  csname node  1 path csname fill 	 fi  if frame  line color  csname node  1 path csname stroke 	 fi     if imark rk  1   fi  if fmark  fmark  1   fi  if rmark ark  1   fi  nodelabel  1   2     ef rk 1  2      ifnextchar   process imarkopt   i mark  1  2    ef process imarkopt  1   s set 1 	 i mark  ef i mark  1    im x  csname node  1 x csname  my unit  edef ps par  strip PT im x  im x  csname node  1 y csname  my unit  edef ps pa r ps par  strip PT im x  im x  i length  my unit  edef ps pa r ps par  strip PT im x  i angle space   put 0 0   special   s initps  line color  csname node  1 path csname  path a false upath cvlit def s ATnul s AHparam  ps par  node mark      ef fmark 1  2      ifnextchar   process fmarkopt   f mark  1  2    ef process fmarkopt  1   s set 1 	 f mark  ef f mark  1    im x  csname node  1 x csname  my unit  edef ps par  strip PT im x  im x  csname node  1 y csname  my unit  edef ps pa r ps par  strip PT im x  im x  f length  my unit  edef ps pa r ps par  strip PT im x  f angle space   put 0 0   special   s initps  line color  csname node  1 path csname  path a false upath cvlit def s AHparam s ATnul  ps par  node mark      ef ark 1  2      ifnextchar   process rmarkopt   r mark  1  2    ef process rmarkopt  1   s set 1 	 r mark  ef r mark  1     ifnum csname node  1 w csname -1 im x  csname node  1 x csname  my unit  edef ps path  strip PT im x  im x  csname node  1 y csname  my unit  edef ps pat h ps path  strip PT im x   edef ps pat h ps path  csname node  1 n csname space  im x  csname node  1 rad csname  my unit  edef ps pat h ps path  strip PT im x   edef ps pat h ps path  csname node  1 a csname space  im y  rep dist  my unit  edef ps pat h ps path  arc radius  strip PT im y  psrpolygonpath space   put 0 0   special   s initps  line color  ps path stroke    else im x  csname node  1 x csname  my unit  edef ps pat h strip PT im x  im x  csname node  1 y csname  my unit  edef ps pat h ps path  strip PT im x  im y - rep dist  my unit im x  csname node  1 w csname  my unit  advance im x im y advance im x im y  edef ps pat h ps path  strip PT im x  im x  csname node  1 h csname  my unit  advance im x im y advance im x im y  edef ps pat h ps path  strip PT im x  im x  csname node  1 r csname  my unit  advance im x im y  edef ps pat h ps path  strip PT im x   put 0 0   special   s initps  line color  ps path  psovalpath stroke    fi     newif if cosneg  newif if sinneg ef nodelabel 1  2   3    ifnextchar   process nodelabelopt   node label  1  2   3    ef process nodelabelopt  1   s set 1 	 node label  ef node label  1   2   unitlength   my unit  edef cs x  csname node  1 x csname   edef cs  y csname node  1 y csname   if ExtNL  node diam  1  NL angle   setcounte rcnt a   cs nd 2  edef cs n r hecnt a   setbox emp box hbo x selectfont  2   setcounte rcnt a   wd emp box    my unit   edef cs b w hecnt a   setcounte rcnt a    ht emp box  p emp box     my unit   edef cs b h hecnt a    cosnegfalse   sinnegfalse im x  cs cos pt  ifnum im x<0   cosnegtrue im x - im x  fi  edef cs absco s strip PT im x  im x  cs sin pt  ifnum im x<0   sinnegtrue im x - im x  fi  edef cs abssi n strip PT im x   ifnum csname node  1 w csname -1  setcounte rcnt c   cs nr  NL dist    cs bw  rea l cs abscos   cs bh  rea l cs abssin   2   setcounte rcnt a   cs x  hecnt c  rea l cs cos    setcounte rcnt b   cs y  hecnt c  rea l cs sin    put hecnt a  hecnt b   makebox 0 0   selectfont  2    else  setcounte rcnt a     cs h  cs bh  2  NL dist   rea l cs abscos    setcounte rcnt b     cs w  cs bw  2- cs r   rea l cs abssin    ifnum hecnt a< hecnt b  setcounte rcnt c    cs h  cs bh  2  NL dist   if sinneg  setcounte rcnt c  - hecnt c   fi  setcounte rcnt a   cs x  hecnt c  rea l cs cos   rea l cs sin    setcounte rcnt b   cs y  hecnt c   put hecnt a  hecnt b   makebox 0 0   selectfont  2    else  setcounte rcnt a     cs w  cs bw  2  NL dist   rea l cs abssin    setcounte rcnt b     cs h  cs bh  2- cs r   rea l cs abscos    ifnum hecnt a< hecnt b  setcounte rcnt c    cs w  cs bw  2  NL dist   if cosneg  setcounte rcnt c  - hecnt c   fi  setcounte rcnt a   cs x  hecnt c   setcounte rcnt b   cs y  hecnt c  rea l cs sin   rea l cs cos    put hecnt a  hecnt b   makebox 0 0   selectfont  2    else  setcounte rcnt a   cs r-  cs w  cs bw  2   edef cs x x hecnt a   setcounte rcnt a   cs r-  cs h  cs bh  2   edef cs y y hecnt a   setcounte rcnt a    cs r  NL dist    cs r  NL dist    edef cs li m hecnt a  ef cs tmi n0   setcounte rcnt a   NL dist   cs bw  cs bh  2   edef cs tma x hecnt a   setcounte rcnt c  10    whilenum hecnt c>0  o  setcounter cnt a    cs tmin  cs tmax  2   edef cs  t hecnt a   setcounte rcnt a    cs nr  cs t   rea l cs abscos   cs xx   setcounte rcnt b    cs nr  cs t   rea l cs abssin   cs yy   setcounte rcnt a   hecnt a  hecnt a   hecnt b  hecnt b   ifnum hecnt a< cs lim  edef cs tmi n cs t   else  edef cs tma x cs t   fi  addtocounte rcnt c  -1    setcounte rcnt a   cs x   cs nr  cs t   rea l cs cos    setcounte rcnt b   cs y   cs nr  cs t   rea l cs sin    put hecnt a  hecnt b   makebox 0 0   selectfont  2    fi  fi  fi  else  CalculateCo s NL angle   edef cs co s UseCos  NL angle    CalculateSi n NL angle   edef cs si n UseSin  NL angle    setcounte rcnt a   cs x  NL dist  rea l cs cos    setcounte rcnt b   cs y  NL dist  rea l cs sin    put hecnt a  hecnt b   makebox 0 0   selectfont  2    fi    ef rawedge 1  2   3    ifnextchar   process edgeopt   raw edge  1  2   3    ef process edgeopt  1   s set 1 	 raw edge  ef raw edge  1  2   3  setcounter cnt a   csname node  1 x csname    E sxo   edef cs x a hecnt a   setcounte rcnt a   csname node  1 y csname    E syo   edef cs y a hecnt a   setcounte rcnt a   csname node  2 x csname    E exo   edef cs x d hecnt a   setcounte rcnt a   csname node  2 y csname    E eyo   edef cs y d hecnt a   setcounte rcnt a   cs xd- cs xa   setcounte rcnt b   cs yd- cs ya   setcounte rcnt c   hecnt a  hecnt a  hecnt b  hecnt b   ifnum hecnt c 0  PackageErro rgastex  drawedge  1  2     ypeou tThe starting and ending nodes should not have the same coordinates    else s sqr t hecnt c   setcounte rcnt b   cs xa  cs xd-4  curve depth   cs yd- cs ya   he sqrt   setcounte rcnt a   hecnt b  cs xa  3  edef cs x b hecnt a   setcounte rcnt a   hecnt b  cs xd  3  edef cs x c hecnt a   setcounte rcnt b   cs ya  cs yd 4  curve depth   cs xd- cs xa   he sqrt   setcounte rcnt a   hecnt b  cs ya  3  edef cs y b hecnt a   setcounte rcnt a   hecnt b  cs yd  3  edef cs y c hecnt a   unitlength   my unit raw b edge  1  2   3   fi   ef rawqbedge 1  2   3    ifnextchar   process qbedgeopt   raw qbedge  1  2   3    ef process qbedgeopt  1   s set 1 	 raw qbedge  ef raw qbedge  1  2  3  4   5  setcounter cnt a   csname node  1 x csname    E sxo   edef cs x a hecnt a   setcounte rcnt a   csname node  1 y csname    E syo   edef cs y a hecnt a   setcounte rcnt a   csname node  4 x csname    E exo   edef cs x d hecnt a   setcounte rcnt a   csname node  4 y csname    E eyo   edef cs y d hecnt a   setcounte rcnt b  2  rati o 2 unitlength    my unit    setcounte rcnt a    cs xa  hecnt b  3  edef cs x b hecnt a   setcounte rcnt a    cs xd  hecnt b  3  edef cs x c hecnt a   setcounte rcnt b  2  rati o 3 unitlength    my unit    setcounte rcnt a    cs ya  hecnt b  3  edef cs y b hecnt a   setcounte rcnt a    cs yd  hecnt b  3  edef cs y c hecnt a   unitlength   my unit raw b edge  1  4   5    ef rawqbpedge 1  2   3    ifnextchar   process qbpedgeopt   raw qbpedge  1  2   3    ef process qbpedgeopt  1   s set 1 	 raw qbpedge  ef raw qbpedge  1  2  3  4   5  setcounter cnt a   csname node  1 x csname    E sxo   edef cs x a hecnt a   setcounte rcnt a   csname node  1 y csname    E syo   edef cs y a hecnt a   setcounte rcnt a   csname node  3 x csname    E exo   edef cs x d hecnt a   setcounte rcnt a   csname node  3 y csname    E eyo   edef cs y d hecnt a   edef cs sangl e 2   CalculateCos cs sangle  CalculateSin cs sangle  edef cs eangl e 4   CalculateCos cs eangle  CalculateSin cs eangle  setcounte rcnt a  1000  rea l UseCos cs sangle   rea l UseSin cs eangle  -1000  rea l UseSin cs sangle   rea l UseCos cs eangle    ifnum hecnt a 0  PackageErro rgastex  drawqbpedge  1  2  3  4     ypeou tThe angles do not allow to compute the intersection point    else  setcounte rcnt c     cs xd- cs xa  1000  rea l UseSin cs eangle  -  cs yd- cs ya  1000  rea l UseCos cs eangle     hecnt a   setcounte rcnt b  2   cs xa  hecnt c  rea l UseCos cs sangle     setcounte rcnt a    cs xa  hecnt b  3  edef cs x b hecnt a   setcounte rcnt a    cs xd  hecnt b  3  edef cs x c hecnt a   setcounte rcnt b  2   cs ya  hecnt c  rea l UseSin cs sangle     setcounte rcnt a    cs ya  hecnt b  3  edef cs y b hecnt a   setcounte rcnt a    cs yd  hecnt b  3  edef cs y c hecnt a   unitlength   my unit raw b edge  1  3   5   fi   ef rawbpedge 1  2   3    ifnextchar   process bpedgeopt   raw bpedge  1  2   3    ef process bpedgeopt  1   s set 1 	 raw bpedge  ef raw bpedge  1  2  3  4  5  6   7  setcounter cnt a   csname node  1 x csname    E sxo   edef cs x a hecnt a   setcounte rcnt a   csname node  1 y csname    E syo   edef cs y a hecnt a   setcounte rcnt a   csname node  4 x csname    E exo   edef cs x d hecnt a   setcounte rcnt a   csname node  4 y csname    E eyo   edef cs y d hecnt a   setcounte rcnt b  1  rati o 3 unitlength    my unit    edef cs angl e 2   CalculateCos cs angle  CalculateSin cs angle  setcounte rcnt a   cs xa  hecnt b  rea l UseCos cs angle    edef cs x b hecnt a   setcounte rcnt a   cs ya  hecnt b  rea l UseSin cs angle    edef cs y b hecnt a   setcounte rcnt b  1  rati o 6 unitlength    my unit    edef cs angl e 5   CalculateCos cs angle  CalculateSin cs angle  setcounte rcnt a   cs xd  hecnt b  rea l UseCos cs angle    edef cs x c hecnt a   setcounte rcnt a   cs yd  hecnt b  rea l UseSin cs angle    edef cs y c hecnt a   unitlength   my unit raw b edge  1  4   7    ef rawbcedge 1  2   3    ifnextchar   process bcedgeopt   raw bcedge  1  2   3    ef process bcedgeopt  1   s set 1 	 raw bcedge  ef raw bcedge  1  2  3  4  5  6   7  setcounter cnt a   csname node  1 x csname    E sxo   edef cs x a hecnt a   setcounte rcnt a   csname node  1 y csname    E syo   edef cs y a hecnt a   setcounte rcnt a   csname node  4 x csname    E exo   edef cs x d hecnt a   setcounte rcnt a   csname node  4 y csname    E eyo   edef cs y d hecnt a   setcounte rcnt a  1  rati o 2 unitlength    my unit    edef cs x b hecnt a   setcounte rcnt a  1  rati o 3 unitlength    my unit    edef cs y b hecnt a   setcounte rcnt a  1  rati o 5 unitlength    my unit    edef cs x c hecnt a   setcounte rcnt a  1  rati o 6 unitlength    my unit    edef cs y c hecnt a   unitlength   my unit raw b edge  1  4   7    ef rawloop 1  2   3    ifnextchar   process loopopt   raw loop  1  2   3    ef process loopopt  1   s set 1 	 raw loop  ef raw loop  1   2  unitlength   my unit  setcounter cnt a   csname node  1 x csname    E sxo   edef cs x a hecnt a   setcounte rcnt a   csname node  1 y csname    E syo   edef cs y a hecnt a   edef cs x d cs xa   edef cs y d cs ya   node diam  1  loop angle   setcounte rcnt a  2   cs nd 2  loop diam  3   setcounte rcnt b   loop diam 1732 1000   setcounte rcnt c    cs xa  hecnt a  real  cs cos - hecnt b  rea l cs sin    if loopCW  edef cs x b hecnt c   else  edef cs x c hecnt c   fi  setcounte rcnt c    cs xa  hecnt a  real  cs cos   hecnt b  rea l cs sin    if loopCW  edef cs x c hecnt c   else  edef cs x b hecnt c   fi  setcounte rcnt c    cs ya  hecnt a  real  cs sin   hecnt b  rea l cs cos    if loopCW  edef cs y b hecnt c   else  edef cs y c hecnt c   fi  setcounte rcnt c    cs ya  hecnt a  real  cs sin - hecnt b  rea l cs cos    if loopCW  edef cs y c hecnt c   else  edef cs y b hecnt c   fi raw b edge  1  1   2    ef rawline 1  2   group  setcounter cnt a  0   edef ps para m    ifnextchar   process drawlineopt   raw line  1  2   ef process drawlineopt  1   s set 1 	 raw line  ef raw line  1  2    setcounter cnt a   hecnt a 1  im x  1 unitlength  edef ps para m ps param  strip PT im x  im x  2 unitlength  edef ps para m ps param  strip PT im x    ifnextchar   raw line    put 0 0   special   s initps  line color s ATparam s AHparam  ps param hecnt a space  arc radius  pslines   group    ef rawcircle 1  2      ifnextchar   process circleopt   raw circle  1  2    ef process circleopt  1   s set 1 	 raw circle  ef raw circle  1  2  3    im x  1 unitlength  edef ps x  strip PT im x  im x  2 unitlength  edef ps  y strip PT im x  im x  3 unitlength  edef ps  d strip PT im x   put 0 0   special   s initps  if fill 	  fill color  ps x  ps y  ps d 2 div  pscirclepath fill 	 fi  if frame  line color  ps x  ps y  ps d 2 div  pscirclepath stroke 	 fi       ef rawrect 1  2      ifnextchar   process rectopt   raw rect  1  2    ef process rectopt  1   s set 1 	 raw rect  ef raw rect  1  2  3  4    im x  1 unitlength  edef ps x  strip PT im x  im x  2 unitlength  edef ps  y strip PT im x  im x  3 unitlength  edef ps  a strip PT im x  im x  4 unitlength  edef ps  b strip PT im x   put 0 0   special   s initps  if fill 	  fill color  ps x  ps y  ps a  ps b  psrectpath fill 	 fi  if frame  line color  ps x  ps y  ps a  ps b  psrectpath stroke 	 fi       ef rawoval 1  2      ifnextchar   process ovalopt   raw oval  1  2    ef process ovalopt  1   s set 1 	 raw oval  ef raw oval  1  2  3  4  5    im x  1 unitlength  edef ps path  strip PT im x  im x  2 unitlength  edef ps pat h ps path  strip PT im x  im x  3 unitlength  edef ps pat h ps path  strip PT im x  im x  4 unitlength  edef ps pat h ps path  strip PT im x  im x  5 unitlength  edef ps pat h ps path  strip PT im x   edef ps pat h ps path  psovalpath space   put 0 0   special   s initps  if fill 	  fill color  ps path fill 	 fi  if frame  line color  ps path stroke 	 fi       ef rawpolygon 1  2   group  setcounter cnt a  0   edef ps para m    ifnextchar   process polygonopt   raw polygon  1  2   ef process polygonopt  1   s set 1 	 raw polygon  ef raw polygon  1  2    setcounter cnt a   hecnt a 1  im x  1 unitlength  edef ps para m ps param  strip PT im x  im x  2 unitlength  edef ps para m ps param  strip PT im x    ifnextchar   raw polygon    put 0 0   special   s initps  if fill  fill color  ps param hecnt a space  arc radius  pspolygonpath fill  fi  if frame  line color  ps param hecnt a space  arc radius  pspolygonpath stroke  fi    group    ef rawrpolygon 1  2   3   group   ifnextchar   process rpolygonopt   raw rpolygon  1  2   3   ef process rpolygonopt  1   s set 1 	 raw rpolygon  ef raw rpolygon  1  2   3  4   im x  1 unitlength im y  2 unitlength  edef ps path  strip PT im x  strip PT im y  3 space  im x  4 unitlength  edef ps pat h ps path  strip PT im x   edef ps pat h ps path  poly angle space  arc radius 0  psrpolygonpath space   put 0 0   special   s initps  if fill  fill color  ps path fill  fi  if frame  line color  ps path stroke  fi    group  ef rawccurve 1  2   group  setcounter cnt a  0   edef ps para m    ifnextchar   process drawccurveopt   raw c curve  1  2   ef process drawccurveopt  1   s set 1 	 raw c curve  ef raw c curve  1  2    setcounter cnt a   hecnt a 1  im x  1 unitlength  edef ps para m ps param  strip PT im x  im x  2 unitlength  edef ps para m ps param  strip PT im x    ifnextchar   raw c curve    put 0 0   special   s initps  if fill 	  fill color  ps param hecnt a space  psccurvepath fill 	 fi  if frame  line color  ps param hecnt a space  psccurvepath stroke 	 fi    group    ef rawcurve 1  2   group  setcounter cnt a  0   edef ps para m    ifnextchar   process drawcurveopt   raw curve  1  2   ef process drawcurveopt  1   s set 1 	 raw curve  ef raw curve  1  2    setcounter cnt a   hecnt a 1  im x  1 unitlength  edef ps para m ps param  strip PT im x  im x  2 unitlength  edef ps para m ps param  strip PT im x    ifnextchar   raw curve    put 0 0   special   s initps  line color s ATparam s AHparam  ps param hecnt a space  pscurve   group    ef rawqbezier 1  2      ifnextchar   process drawqbezieropt   raw q bezier  1  2    ef process drawqbezieropt  1   s set 1 	 raw q bezier  ef raw q bezier  1  2  3  4  5  6    im x  1 unitlength  edef ps xa  strip PT im x  im x  2 unitlength  edef ps y a strip PT im x  im x  3 unitlength  edef ps x b strip PT im x  im x  4 unitlength  edef ps y b strip PT im x  im x  5 unitlength  edef ps x c strip PT im x  im x  6 unitlength  edef ps y c strip PT im x   put 0 0   special   s initps  line color s ATparam s AHparam 	 ps xa  ps ya  ps xb  ps yb  ps xc  ps yc  ps qbezier      ef rawcbezier 1  2      ifnextchar   process drawcbezieropt   raw c bezier  1  2    ef process drawcbezieropt  1   s set 1 	 raw c bezier  ef raw c bezier  1  2  3  4  5  6  7  8    im x  1 unitlength  edef ps xa  strip PT im x  im x  2 unitlength  edef ps y a strip PT im x  im x  3 unitlength  edef ps x b strip PT im x  im x  4 unitlength  edef ps y b strip PT im x  im x  5 unitlength  edef ps x c strip PT im x  im x  6 unitlength  edef ps y c strip PT im x  im x  7 unitlength  edef ps x d strip PT im x  im x  8 unitlength  edef ps y d strip PT im x   put 0 0   special   s initps  line color s ATparam s AHparam 	 ps xa  ps ya  ps xb  ps yb  ps xc  ps yc  ps xd  ps yd  ps cbezier      ef node diam  1  2    CalculateCos  2   edef cs co s UseCos  2    CalculateSi n 2   edef cs si n UseSin  2    ifnum csname node  1 w csname -1  edef cs ra d csname node  1 rad csname   edef cs  n csname node  1 n csname   edef cs  a csname node  1 a csname   setcounte rcnt b  360  cs n  edef cs  b hecnt b   setcounte rcnt a   2- cs a    whilenum hecnt a> hecnt b  o setcounter cnt a   hecnt a- hecnt b     whilenum hecnt a<0  o setcounter cnt a   hecnt a  hecnt b    setcounte rcnt b   hecnt b 2   setcounte rcnt a   hecnt a- hecnt b   ifnum hecnt a<0  setcounte rcnt a  - hecnt a   fi  CalculateCo s hecnt a   CalculateCo s hecnt b   setcounte rcnt c  2  cs rad  rea l UseCos  hecnt b    rea l UseCos  hecnt a     edef cs n d hecnt c   else  edef cs  w csname node  1 w csname   edef cs  h csname node  1 h csname   edef cs  r csname node  1 r csname   setcounte rcnt a   cs r  cs r  edef cs r r hecnt a   setcounte rcnt a    cs h- cs rr   rea l cs cos    ifnum hecnt a<0 edef cs  A- hecnt a  else edef cs  A hecnt a  fi  setcounte rcnt a    cs w- cs rr   rea l cs sin    ifnum hecnt a<0 edef cs  B- hecnt a  else edef cs  B hecnt a  fi  setcounte rcnt a   cs w  rea l cs sin    ifnum hecnt a<0 setcounte rcnt a  - hecnt a  fi  ifnum hecnt a< cs A  setcounte rcnt c   cs w  rea l cs cos    ifnum hecnt c<0 edef cs n d- hecnt c  else edef cs n d hecnt c  fi  else  setcounte rcnt a   cs h  rea l cs cos    ifnum hecnt a<0 setcounte rcnt a  - hecnt a  fi  ifnum hecnt a< cs B  setcounte rcnt c   cs h  rea l cs sin    ifnum hecnt c<0 edef cs n d- hecnt c  else edef cs n d hecnt c  fi  else  setcounte rcnt a   cs rr  cs rr-  cs B- cs A    cs B- cs A   s sqr t hecnt a   setcounte rcnt a    cs w- cs rr   rea l cs cos    ifnum hecnt a<0 edef cs  E- hecnt a  else edef cs  E hecnt a  fi  setcounte rcnt a    cs h- cs rr   rea l cs sin    ifnum hecnt a<0 edef cs  F- hecnt a  else edef cs  F hecnt a  fi  setcounte rcnt a   he sqrt  cs E  cs F  edef cs n d hecnt a   fi  fi  fi   ef raw b edge  1  2   3  im x  cs xa unitlength  edef ps xa  strip PT im x  im x  cs ya unitlength  edef ps y a strip PT im x  im x  cs xb unitlength  edef ps x b strip PT im x  im x  cs yb unitlength  edef ps y b strip PT im x  im x  cs xc unitlength  edef ps x c strip PT im x  im x  cs yc unitlength  edef ps y c strip PT im x  im x  cs xd unitlength  edef ps x d strip PT im x  im x  cs yd unitlength  edef ps y d strip PT im x   put 0 0   special   s initps  line color  csname node  1 path csname  path a false upath cvlit def  csname node  2 path csname  path b false upath cvlit def 	 s ATparam s AHparam 	 ps xa  ps ya  ps xb  ps yb  ps xc  ps yc  ps xd  ps yd  ps r cbezier    ef   N100   setcounte rcnt a   cs xd- cs xa 3   cs xb- cs xc   edef   A hecnt a   setcounte rcnt a  3   cs xa  cs xc-2  cs xb   edef   B hecnt a   setcounte rcnt a  3   cs xb- cs xa   edef   C hecnt a   setcounte rcnt a      A  EL p   N   B   EL p   N   C   EL p   N  cs xa   edef cs  x hecnt a   setcounte rcnt a   3   A  EL p   N 2   B   EL p   N   C   edef cs delta x hecnt a   setcounte rcnt a   cs yd- cs ya 3   cs yb- cs yc   edef   A hecnt a   setcounte rcnt a  3   cs ya  cs yc-2  cs yb   edef   B hecnt a   setcounte rcnt a  3   cs yb- cs ya   edef   C hecnt a   setcounte rcnt a      A  EL p   N   B   EL p   N   C   EL p   N  cs ya   edef cs  y hecnt a   setcounte rcnt a   3   A  EL p   N 2   B   EL p   N   C   edef cs delta y hecnt a   setcounte rcnt c   cs deltax  cs deltax  cs deltay  cs deltay  s sqr t hecnt c   ifnum he sqrt 0 ef he sqr t1  fi  if ELdistC  setcounte rcnt c   EL dist   else  setbox emp box hbo x selectfont  3   setcounte rcnt a   wd emp box    my unit    cs deltay   ifnum hecnt a<0  setcounte rcnt a  - hecnt a   fi  setcounte rcnt c    ht emp box  p emp box     my unit    cs deltax   ifnum hecnt c<0  setcounte rcnt c  - hecnt c   fi  setcounte rcnt c   hecnt c  hecnt a    he sqrt   2    EL dist   fi  if r EL s  setcounte rcnt a   cs x    cs deltay   hecnt c   he sqrt   setcounte rcnt b   cs y -  cs deltax   hecnt c   he sqrt   else  setcounte rcnt a   cs x -  cs deltay   hecnt c   he sqrt   setcounte rcnt b   cs y    cs deltax   hecnt c   he sqrt   fi  put hecnt a  hecnt b   makebox 0 0   selectfont  3       newcounte rcnt  a  newcounte rcnt  b  newcounte rcnt  c  ef s sqrt  1  ifnum 1<0 setcounter cnt  a  - 1  else setcounte rcnt  a   1  fi  ifnum hecnt  a>1  setcounte rcnt  b   hecnt  a   setcounte rcnt  c   hecnt  a 1  2  	  whilenum hecnt  b> hecnt  c  o  setcounter cnt  b   hecnt  c   setcounte rcnt  c   hecnt  b  hecnt  a  hecnt  b  2   	 edef he sqr t hecnt  b   else 	 edef he sqr t hecnt  a   fi   ef compatiblegastexu n  unitlength 4pt  my unit  2048sp sset AHnb 1 AHangle 20  ef AH  L strip PT  wholewidth 9 mul   ef AH  l strip PT  wholewidth 9 mul 20 cos mul   ef line widt h strip PT  wholewidth  ef setstatediam   1 sset Nw   1  sset N h  1  sset Nm r  1   ef setvertexdia m setstatediam   setstatedia m6  ef setrepeatedstatediam   1  setcounter cnt a  1  rati o  1 unitlength    my unit    edef repeated dia m hecnt a    setrepeatedstatedia m5  ef setloopdia m sset loopdiam   setloopdia m6  ef settranslabelski p sset ELdist  ef setedgelabelski p sset ELdist   settranslabelski p1  ef setprofcurve   1  setcounter cnt a  1  rati o  1 unitlength    my unit    edef prof curv e hecnt a    setprofcurv e3  ef settransdecal   1  setcounter cnt a  1  rati o  1 unitlength    my unit    edef rans deca l hecnt a    settransdeca l0  ef setedgedeca l settransdecal  ef setmaxbezier   1  ef setnbptbezier   1  ef setprecision   1  ef setpsdas h  ifnextchar   i setpsdash   i setpsdash 0    ef i setpsdash   1    2   	 im y  unitlength  unitlength 1pt sset  dash 0   2    1  	 unitlength  im y 	 ef ps das h   2    1 space    setpsdash   ef pcolo r  ef pictcolor  1   2  ef setpsgray   1 sset linegray   1  sset fillgra y  1    setpsgra y0  ef tstat e  ifnextchar   i letstate   ii letstate   ef i letstate   1   2    3    4   5    sset Nw   1 Nh   1 Nmr   1  t node   3    4   5      ef ii letstate   1    2   3   t node   1    2   3     ef tverte x  ifnextchar   i letvertex   ii letstate   ef i letvertex   1    2    3   4    sset Nw   1 Nh   1 Nmr   1  t node   2    3   4      ef rawstate   1    2  sset Nfill n  raw node   1    2    ef rawvertex   1    2  sset Nfill n Nframe n  raw node   1    2    ef rawcircledverte x rawstate  ef rawinitialstat e   ifnextchar    idrawinitialstate    idrawinitialstate l    ef  idrawinitialstate   1    2    3  sset Nfill n  raw node   2    3   setcounte rcnt a   N w  rati o  my unit   unitlength  2   if  1l rk iangle 180 ilength  hecnt a    2   fi  if  1r rk iangle  0 ilength  hecnt a    2   fi  if  1t rk iangle  90 ilength  hecnt a    2   fi  if  1b rk iangle -90 ilength  hecnt a    2   fi   ef rawfinalstat e   ifnextchar    idrawfinalstate    idrawfinalstate r    ef  idrawfinalstate   1    2    3  sset Nfill n  raw node   2    3   setcounte rcnt a   N w  rati o  my unit   unitlength  2   if  1l  fmark fangle 180 flength  hecnt a    2   fi  if  1r  fmark fangle  0 flength  hecnt a    2   fi  if  1t  fmark fangle  90 flength  hecnt a    2   fi  if  1b  fmark fangle -90 flength  hecnt a    2   fi   ef rawrepeatedstate   1    2  sset Nfill n  raw node   1    2   setcounte rcnt a    N w- repeated diam  2   edef rep dis t hecnt a  ark   1    t s edge  rawedge ef rawtran s  ifnextchar    idrawtrans    idrawtrans l    ef  idrawtrans   1    2   3    4  setcounter cnt a   rans decal  rati o  my unit   unitlength    if  1r s edge ELside r curvedepth  hecnt a    2   3    4   else  if  1b s edge ELside r curvedepth  hecnt a    2   3    4   else s edge ELside l curvedepth  hecnt a    2   3    4   fi fi  ef rawedg e rawtrans  ef rawundirectededge  1   2   3    4   ef AH nb 0   rawtrans  1   2   3    4    ef rawcurvedtran s   ifnextchar    idrawcurvedtrans    idrawcurvedtrans l    ef  idrawcurvedtrans   1    2   3    4  setcounter cnt a   prof curve  rati o  my unit   unitlength    if  1r s edge ELside r curvedepth  hecnt a    2   3    4   else  if  1b s edge ELside r curvedepth  hecnt a    2   3    4   else s edge ELside l curvedepth  hecnt a    2   3    4   fi fi  ef rawcurvededg e rawcurvedtrans  ef rawundirectedcurvededge  1   2   3    4   ef AH nb 0   rawcurvedtrans  1   2   3    4    ef rawqbeziertran s   ifnextchar    idrawqbeziertrans    idrawqbeziertrans l    ef  idrawqbeziertrans   1    2    3   4    5    6  if  1r rawqbedge ELside r    2   3   4   5    6   else  if  1b rawqbedge ELside r    2   3   4   5    6   else rawqbedge ELside l    2   3   4   5    6   fi fi  ef rawqbezieredg e rawqbeziertrans  ef rawundirectedqbezieredge  1   2    3   4    5    6   ef AH nb 0   rawqbeziertrans  1   2    3   4    5    6    ef rawcbeziertran s   ifnextchar    idrawcbeziertrans    idrawcbeziertrans l    ef  idrawcbeziertrans   1    2    3   4    5   6    7    8   if  1r  edef EL s r   else  if  1b  edef EL  sr   else  edef EL  sl   fi fi 	 raw bcedge   2   3   4   7   5   6    8     ef rawcbezieredg e rawcbeziertrans  ef rawundirectedcbezieredge  1   2    3   4    5   6    7    8   ef AH nb 0   rawcbeziertrans  1   2    3   4    5   6    7    8    t s loop  rawloop ef rawloo p  ifnextchar    idrawloop    idrawloop t    ef  idrawloop   1    2    3  if  1l s loop loopangle 180    2    3   fi  if  1r s loop loopangle  0    2    3   fi  if  1t s loop loopangle  90    2    3   fi  if  1b s loop loopangle -90    2    3   fi  ef rawundirectedloop  1   2    3   ef AH nb 0   rawloop  1   2    3      ef compatiblepspictp g ef setpsdash   ifnextchar   i setpsdash   i setpsdash 0    ef i setpsdash   1    2   	 im y  unitlength  unitlength 1pt sset  dash 0   2    1  	 unitlength  im y 	 ef ps das h   2    1 space    setpsdash   ef pcolo r  ef pictcolor  1   2  ef setpsgray   1 sset linegray   1  sset fillgra y  1    setpsgra y0  ef line   1   2    3    xarg   1 relax   yarg   2 relax im x   3 unitlength  special   s initps  line color he  xarg space he  yarg space  strip PT im x  pslatexline     ef vector   1   2    3    xarg   1 relax   yarg   2 relax im x   3 unitlength  special   s initps  line color s ATnul s AHparam he  xarg space he  yarg space  strip PT im x  pslatexvector     ef circl e  ifnextchar    idisk    icircle   ef  icircle   1  im x   1 unitlength  special   s initps  line color  strip PT im x  pscircle     ef  idisk    1  im x   1 unitlength  special   s initps  fill color  strip PT im x  psdisk     ef rawline   1   2    3   4   group  setcounter cnt a  0   edef ps para m   process drawlineopt ATnb 0 AHnb 0    1   2    3   4   ef rawvector   1   2    3   4   group  setcounter cnt a  0   edef ps para m   process drawlineopt ATnb 0 AHnb 1    1   2    3   4   ef rawcircle   1   2    3    sset Nframe y Nfill n  raw circle   1   2   3    ef rawdisk   1   2    3    sset Nframe n Nfill y  raw circle   1   2   3    ef cbezier   1   2    3   4    5   6    7   8   rawcbezier ATnb 0 AHnb 0    1   2   3   4   5   6   7   8   ef cbeziervector   1   2    3   4    5   6    7   8   rawcbezier ATnb 0 AHnb 1    1   2   3   4   5   6   7   8   ef qbezier   1   2    3   4    5   6   rawqbezier ATnb 0 AHnb 0    1   2   3   4   5   6   ef qbeziervector   1   2    3   4    5   6   rawqbezier ATnb 0 AHnb 1    1   2   3   4   5   6     input